// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from "./lni-ffi";
import {
  type FfiConverter, 
  type UniffiByteArray, 
  type UniffiObjectFactory, 
  type UniffiRustArcPtr, 
  type UnsafeMutableRawPointer, 
  AbstractFfiConverterByteArray, 
  FfiConverterArray, 
  FfiConverterBool, 
  FfiConverterFloat64, 
  FfiConverterInt32, 
  FfiConverterInt64, 
  FfiConverterObject, 
  FfiConverterOptional, 
  FfiConverterUInt64, 
  RustBuffer, 
  UniffiAbstractObject, 
  UniffiError, 
  UniffiInternalError, 
  UniffiRustCaller, 
  destructorGuardSymbol, 
  pointerLiteralSymbol, 
  uniffiCreateFfiConverterString, 
  uniffiCreateRecord, 
  uniffiRustCallAsync, 
  uniffiTypeNameSymbol, 
  variantOrdinalSymbol } from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.











export type BalancesResponse = {
    onchain: OnchainBalanceResponse,
    lightning: LightningBalanceResponse
}

/**
 * Generated factory for {@link BalancesResponse} record objects.
 */
export const BalancesResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<BalancesResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link BalancesResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link BalancesResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<BalancesResponse>,
    });
})();

const FfiConverterTypeBalancesResponse = (() => {
    type TypeName = BalancesResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                onchain: FfiConverterTypeOnchainBalanceResponse.read(from), 
                lightning: FfiConverterTypeLightningBalanceResponse.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeOnchainBalanceResponse.write(value.onchain, into);
            FfiConverterTypeLightningBalanceResponse.write(value.lightning, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeOnchainBalanceResponse.allocationSize(value.onchain) + 
            FfiConverterTypeLightningBalanceResponse.allocationSize(value.lightning);
            
        }
    };
    return new FFIConverter();
})();


export type Channel = {
    localBalance: /*i64*/bigint,
    localSpendableBalance: /*i64*/bigint,
    remoteBalance: /*i64*/bigint,
    id: string,
    remotePubkey: string,
    fundingTxId: string,
    fundingTxVout: /*i64*/bigint,
    active: boolean,
    public_: boolean,
    internalChannel: string,
    confirmations: /*i64*/bigint,
    confirmationsRequired: /*i64*/bigint,
    forwardingFeeBaseMsat: /*i64*/bigint,
    unspendablePunishmentReserve: /*i64*/bigint,
    counterpartyUnspendablePunishmentReserve: /*i64*/bigint,
    error: string,
    isOutbound: boolean
}

/**
 * Generated factory for {@link Channel} record objects.
 */
export const Channel = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Channel, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Channel}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Channel}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Channel>,
    });
})();

const FfiConverterTypeChannel = (() => {
    type TypeName = Channel;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                localBalance: FfiConverterInt64.read(from), 
                localSpendableBalance: FfiConverterInt64.read(from), 
                remoteBalance: FfiConverterInt64.read(from), 
                id: FfiConverterString.read(from), 
                remotePubkey: FfiConverterString.read(from), 
                fundingTxId: FfiConverterString.read(from), 
                fundingTxVout: FfiConverterInt64.read(from), 
                active: FfiConverterBool.read(from), 
                public_: FfiConverterBool.read(from), 
                internalChannel: FfiConverterString.read(from), 
                confirmations: FfiConverterInt64.read(from), 
                confirmationsRequired: FfiConverterInt64.read(from), 
                forwardingFeeBaseMsat: FfiConverterInt64.read(from), 
                unspendablePunishmentReserve: FfiConverterInt64.read(from), 
                counterpartyUnspendablePunishmentReserve: FfiConverterInt64.read(from), 
                error: FfiConverterString.read(from), 
                isOutbound: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.localBalance, into);
            FfiConverterInt64.write(value.localSpendableBalance, into);
            FfiConverterInt64.write(value.remoteBalance, into);
            FfiConverterString.write(value.id, into);
            FfiConverterString.write(value.remotePubkey, into);
            FfiConverterString.write(value.fundingTxId, into);
            FfiConverterInt64.write(value.fundingTxVout, into);
            FfiConverterBool.write(value.active, into);
            FfiConverterBool.write(value.public_, into);
            FfiConverterString.write(value.internalChannel, into);
            FfiConverterInt64.write(value.confirmations, into);
            FfiConverterInt64.write(value.confirmationsRequired, into);
            FfiConverterInt64.write(value.forwardingFeeBaseMsat, into);
            FfiConverterInt64.write(value.unspendablePunishmentReserve, into);
            FfiConverterInt64.write(value.counterpartyUnspendablePunishmentReserve, into);
            FfiConverterString.write(value.error, into);
            FfiConverterBool.write(value.isOutbound, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.localBalance) + 
            FfiConverterInt64.allocationSize(value.localSpendableBalance) + 
            FfiConverterInt64.allocationSize(value.remoteBalance) + 
            FfiConverterString.allocationSize(value.id) + 
            FfiConverterString.allocationSize(value.remotePubkey) + 
            FfiConverterString.allocationSize(value.fundingTxId) + 
            FfiConverterInt64.allocationSize(value.fundingTxVout) + 
            FfiConverterBool.allocationSize(value.active) + 
            FfiConverterBool.allocationSize(value.public_) + 
            FfiConverterString.allocationSize(value.internalChannel) + 
            FfiConverterInt64.allocationSize(value.confirmations) + 
            FfiConverterInt64.allocationSize(value.confirmationsRequired) + 
            FfiConverterInt64.allocationSize(value.forwardingFeeBaseMsat) + 
            FfiConverterInt64.allocationSize(value.unspendablePunishmentReserve) + 
            FfiConverterInt64.allocationSize(value.counterpartyUnspendablePunishmentReserve) + 
            FfiConverterString.allocationSize(value.error) + 
            FfiConverterBool.allocationSize(value.isOutbound);
            
        }
    };
    return new FFIConverter();
})();


export type ClnConfig = {
    url: string,
    rune: string
}

/**
 * Generated factory for {@link ClnConfig} record objects.
 */
export const ClnConfig = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ClnConfig, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ClnConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ClnConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ClnConfig>,
    });
})();

const FfiConverterTypeClnConfig = (() => {
    type TypeName = ClnConfig;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                url: FfiConverterString.read(from), 
                rune: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.url, into);
            FfiConverterString.write(value.rune, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.url) + 
            FfiConverterString.allocationSize(value.rune);
            
        }
    };
    return new FFIConverter();
})();


export type CloseChannelRequest = {
    channelId: string,
    nodeId: string,
    force: boolean
}

/**
 * Generated factory for {@link CloseChannelRequest} record objects.
 */
export const CloseChannelRequest = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CloseChannelRequest, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CloseChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CloseChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CloseChannelRequest>,
    });
})();

const FfiConverterTypeCloseChannelRequest = (() => {
    type TypeName = CloseChannelRequest;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                channelId: FfiConverterString.read(from), 
                nodeId: FfiConverterString.read(from), 
                force: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.channelId, into);
            FfiConverterString.write(value.nodeId, into);
            FfiConverterBool.write(value.force, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.channelId) + 
            FfiConverterString.allocationSize(value.nodeId) + 
            FfiConverterBool.allocationSize(value.force);
            
        }
    };
    return new FFIConverter();
})();


export type CloseChannelResponse = {
}

/**
 * Generated factory for {@link CloseChannelResponse} record objects.
 */
export const CloseChannelResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CloseChannelResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CloseChannelResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CloseChannelResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CloseChannelResponse>,
    });
})();

const FfiConverterTypeCloseChannelResponse = (() => {
    type TypeName = CloseChannelResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
            };
        }
        write(value: TypeName, into: RustBuffer): void {
        }
        allocationSize(value: TypeName): number {
            return 0;
        }
    };
    return new FFIConverter();
})();


export type ConnectPeerRequest = {
    pubkey: string,
    address: string,
    port: /*i64*/bigint
}

/**
 * Generated factory for {@link ConnectPeerRequest} record objects.
 */
export const ConnectPeerRequest = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ConnectPeerRequest, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ConnectPeerRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ConnectPeerRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ConnectPeerRequest>,
    });
})();

const FfiConverterTypeConnectPeerRequest = (() => {
    type TypeName = ConnectPeerRequest;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                pubkey: FfiConverterString.read(from), 
                address: FfiConverterString.read(from), 
                port: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.pubkey, into);
            FfiConverterString.write(value.address, into);
            FfiConverterInt64.write(value.port, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.pubkey) + 
            FfiConverterString.allocationSize(value.address) + 
            FfiConverterInt64.allocationSize(value.port);
            
        }
    };
    return new FFIConverter();
})();


export type CreateInvoiceParams = {
    invoiceType: InvoiceType,
    amountMsats: /*i64*/bigint | undefined,
    offer: string | undefined,
    description: string | undefined,
    descriptionHash: string | undefined,
    expiry: /*i64*/bigint | undefined,
    rPreimage: string | undefined,
    isBlinded: boolean | undefined,
    isKeysend: boolean | undefined,
    isAmp: boolean | undefined,
    isPrivate: boolean | undefined
}

/**
 * Generated factory for {@link CreateInvoiceParams} record objects.
 */
export const CreateInvoiceParams = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<CreateInvoiceParams, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link CreateInvoiceParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link CreateInvoiceParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<CreateInvoiceParams>,
    });
})();

const FfiConverterTypeCreateInvoiceParams = (() => {
    type TypeName = CreateInvoiceParams;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                invoiceType: FfiConverterTypeInvoiceType.read(from), 
                amountMsats: FfiConverterOptionalInt64.read(from), 
                offer: FfiConverterOptionalString.read(from), 
                description: FfiConverterOptionalString.read(from), 
                descriptionHash: FfiConverterOptionalString.read(from), 
                expiry: FfiConverterOptionalInt64.read(from), 
                rPreimage: FfiConverterOptionalString.read(from), 
                isBlinded: FfiConverterOptionalBool.read(from), 
                isKeysend: FfiConverterOptionalBool.read(from), 
                isAmp: FfiConverterOptionalBool.read(from), 
                isPrivate: FfiConverterOptionalBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeInvoiceType.write(value.invoiceType, into);
            FfiConverterOptionalInt64.write(value.amountMsats, into);
            FfiConverterOptionalString.write(value.offer, into);
            FfiConverterOptionalString.write(value.description, into);
            FfiConverterOptionalString.write(value.descriptionHash, into);
            FfiConverterOptionalInt64.write(value.expiry, into);
            FfiConverterOptionalString.write(value.rPreimage, into);
            FfiConverterOptionalBool.write(value.isBlinded, into);
            FfiConverterOptionalBool.write(value.isKeysend, into);
            FfiConverterOptionalBool.write(value.isAmp, into);
            FfiConverterOptionalBool.write(value.isPrivate, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeInvoiceType.allocationSize(value.invoiceType) + 
            FfiConverterOptionalInt64.allocationSize(value.amountMsats) + 
            FfiConverterOptionalString.allocationSize(value.offer) + 
            FfiConverterOptionalString.allocationSize(value.description) + 
            FfiConverterOptionalString.allocationSize(value.descriptionHash) + 
            FfiConverterOptionalInt64.allocationSize(value.expiry) + 
            FfiConverterOptionalString.allocationSize(value.rPreimage) + 
            FfiConverterOptionalBool.allocationSize(value.isBlinded) + 
            FfiConverterOptionalBool.allocationSize(value.isKeysend) + 
            FfiConverterOptionalBool.allocationSize(value.isAmp) + 
            FfiConverterOptionalBool.allocationSize(value.isPrivate);
            
        }
    };
    return new FFIConverter();
})();


export type LightningBalanceResponse = {
    totalSpendable: /*i64*/bigint,
    totalReceivable: /*i64*/bigint,
    nextMaxSpendable: /*i64*/bigint,
    nextMaxReceivable: /*i64*/bigint,
    nextMaxSpendableMpp: /*i64*/bigint,
    nextMaxReceivableMpp: /*i64*/bigint
}

/**
 * Generated factory for {@link LightningBalanceResponse} record objects.
 */
export const LightningBalanceResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<LightningBalanceResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LightningBalanceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link LightningBalanceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<LightningBalanceResponse>,
    });
})();

const FfiConverterTypeLightningBalanceResponse = (() => {
    type TypeName = LightningBalanceResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                totalSpendable: FfiConverterInt64.read(from), 
                totalReceivable: FfiConverterInt64.read(from), 
                nextMaxSpendable: FfiConverterInt64.read(from), 
                nextMaxReceivable: FfiConverterInt64.read(from), 
                nextMaxSpendableMpp: FfiConverterInt64.read(from), 
                nextMaxReceivableMpp: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.totalSpendable, into);
            FfiConverterInt64.write(value.totalReceivable, into);
            FfiConverterInt64.write(value.nextMaxSpendable, into);
            FfiConverterInt64.write(value.nextMaxReceivable, into);
            FfiConverterInt64.write(value.nextMaxSpendableMpp, into);
            FfiConverterInt64.write(value.nextMaxReceivableMpp, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.totalSpendable) + 
            FfiConverterInt64.allocationSize(value.totalReceivable) + 
            FfiConverterInt64.allocationSize(value.nextMaxSpendable) + 
            FfiConverterInt64.allocationSize(value.nextMaxReceivable) + 
            FfiConverterInt64.allocationSize(value.nextMaxSpendableMpp) + 
            FfiConverterInt64.allocationSize(value.nextMaxReceivableMpp);
            
        }
    };
    return new FFIConverter();
})();


export type ListTransactionsParams = {
    from: /*i64*/bigint,
    limit: /*i64*/bigint,
    paymentHash: string | undefined
}

/**
 * Generated factory for {@link ListTransactionsParams} record objects.
 */
export const ListTransactionsParams = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<ListTransactionsParams, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link ListTransactionsParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link ListTransactionsParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<ListTransactionsParams>,
    });
})();

const FfiConverterTypeListTransactionsParams = (() => {
    type TypeName = ListTransactionsParams;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                from: FfiConverterInt64.read(from), 
                limit: FfiConverterInt64.read(from), 
                paymentHash: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.from, into);
            FfiConverterInt64.write(value.limit, into);
            FfiConverterOptionalString.write(value.paymentHash, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.from) + 
            FfiConverterInt64.allocationSize(value.limit) + 
            FfiConverterOptionalString.allocationSize(value.paymentHash);
            
        }
    };
    return new FFIConverter();
})();


export type LndConfig = {
    url: string,
    macaroon: string
}

/**
 * Generated factory for {@link LndConfig} record objects.
 */
export const LndConfig = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<LndConfig, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link LndConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link LndConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<LndConfig>,
    });
})();

const FfiConverterTypeLndConfig = (() => {
    type TypeName = LndConfig;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                url: FfiConverterString.read(from), 
                macaroon: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.url, into);
            FfiConverterString.write(value.macaroon, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.url) + 
            FfiConverterString.allocationSize(value.macaroon);
            
        }
    };
    return new FFIConverter();
})();


export type NodeConnectionInfo = {
    pubkey: string,
    address: string,
    port: /*i64*/bigint
}

/**
 * Generated factory for {@link NodeConnectionInfo} record objects.
 */
export const NodeConnectionInfo = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<NodeConnectionInfo, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NodeConnectionInfo}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link NodeConnectionInfo}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<NodeConnectionInfo>,
    });
})();

const FfiConverterTypeNodeConnectionInfo = (() => {
    type TypeName = NodeConnectionInfo;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                pubkey: FfiConverterString.read(from), 
                address: FfiConverterString.read(from), 
                port: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.pubkey, into);
            FfiConverterString.write(value.address, into);
            FfiConverterInt64.write(value.port, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.pubkey) + 
            FfiConverterString.allocationSize(value.address) + 
            FfiConverterInt64.allocationSize(value.port);
            
        }
    };
    return new FFIConverter();
})();


export type NodeInfo = {
    alias: string,
    color: string,
    pubkey: string,
    network: string,
    blockHeight: /*i64*/bigint,
    blockHash: string,
    sendBalanceMsat: /*i64*/bigint,
    receiveBalanceMsat: /*i64*/bigint,
    feeCreditBalanceMsat: /*i64*/bigint,
    unsettledSendBalanceMsat: /*i64*/bigint,
    unsettledReceiveBalanceMsat: /*i64*/bigint,
    pendingOpenSendBalance: /*i64*/bigint,
    pendingOpenReceiveBalance: /*i64*/bigint
}

/**
 * Generated factory for {@link NodeInfo} record objects.
 */
export const NodeInfo = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<NodeInfo, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NodeInfo}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link NodeInfo}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<NodeInfo>,
    });
})();

const FfiConverterTypeNodeInfo = (() => {
    type TypeName = NodeInfo;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                alias: FfiConverterString.read(from), 
                color: FfiConverterString.read(from), 
                pubkey: FfiConverterString.read(from), 
                network: FfiConverterString.read(from), 
                blockHeight: FfiConverterInt64.read(from), 
                blockHash: FfiConverterString.read(from), 
                sendBalanceMsat: FfiConverterInt64.read(from), 
                receiveBalanceMsat: FfiConverterInt64.read(from), 
                feeCreditBalanceMsat: FfiConverterInt64.read(from), 
                unsettledSendBalanceMsat: FfiConverterInt64.read(from), 
                unsettledReceiveBalanceMsat: FfiConverterInt64.read(from), 
                pendingOpenSendBalance: FfiConverterInt64.read(from), 
                pendingOpenReceiveBalance: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.alias, into);
            FfiConverterString.write(value.color, into);
            FfiConverterString.write(value.pubkey, into);
            FfiConverterString.write(value.network, into);
            FfiConverterInt64.write(value.blockHeight, into);
            FfiConverterString.write(value.blockHash, into);
            FfiConverterInt64.write(value.sendBalanceMsat, into);
            FfiConverterInt64.write(value.receiveBalanceMsat, into);
            FfiConverterInt64.write(value.feeCreditBalanceMsat, into);
            FfiConverterInt64.write(value.unsettledSendBalanceMsat, into);
            FfiConverterInt64.write(value.unsettledReceiveBalanceMsat, into);
            FfiConverterInt64.write(value.pendingOpenSendBalance, into);
            FfiConverterInt64.write(value.pendingOpenReceiveBalance, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.alias) + 
            FfiConverterString.allocationSize(value.color) + 
            FfiConverterString.allocationSize(value.pubkey) + 
            FfiConverterString.allocationSize(value.network) + 
            FfiConverterInt64.allocationSize(value.blockHeight) + 
            FfiConverterString.allocationSize(value.blockHash) + 
            FfiConverterInt64.allocationSize(value.sendBalanceMsat) + 
            FfiConverterInt64.allocationSize(value.receiveBalanceMsat) + 
            FfiConverterInt64.allocationSize(value.feeCreditBalanceMsat) + 
            FfiConverterInt64.allocationSize(value.unsettledSendBalanceMsat) + 
            FfiConverterInt64.allocationSize(value.unsettledReceiveBalanceMsat) + 
            FfiConverterInt64.allocationSize(value.pendingOpenSendBalance) + 
            FfiConverterInt64.allocationSize(value.pendingOpenReceiveBalance);
            
        }
    };
    return new FFIConverter();
})();


export type NodeStatus = {
    isReady: boolean,
    internalNodeStatus: string
}

/**
 * Generated factory for {@link NodeStatus} record objects.
 */
export const NodeStatus = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<NodeStatus, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link NodeStatus}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link NodeStatus}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<NodeStatus>,
    });
})();

const FfiConverterTypeNodeStatus = (() => {
    type TypeName = NodeStatus;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                isReady: FfiConverterBool.read(from), 
                internalNodeStatus: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterBool.write(value.isReady, into);
            FfiConverterString.write(value.internalNodeStatus, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterBool.allocationSize(value.isReady) + 
            FfiConverterString.allocationSize(value.internalNodeStatus);
            
        }
    };
    return new FFIConverter();
})();


export type OnchainBalanceResponse = {
    spendable: /*i64*/bigint,
    total: /*i64*/bigint,
    reserved: /*i64*/bigint,
    pendingBalancesFromChannelClosures: /*i64*/bigint,
    pendingBalancesDetails: Array<PendingBalanceDetails>,
    internalBalances: string
}

/**
 * Generated factory for {@link OnchainBalanceResponse} record objects.
 */
export const OnchainBalanceResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<OnchainBalanceResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OnchainBalanceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link OnchainBalanceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<OnchainBalanceResponse>,
    });
})();

const FfiConverterTypeOnchainBalanceResponse = (() => {
    type TypeName = OnchainBalanceResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                spendable: FfiConverterInt64.read(from), 
                total: FfiConverterInt64.read(from), 
                reserved: FfiConverterInt64.read(from), 
                pendingBalancesFromChannelClosures: FfiConverterInt64.read(from), 
                pendingBalancesDetails: FfiConverterArrayTypePendingBalanceDetails.read(from), 
                internalBalances: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.spendable, into);
            FfiConverterInt64.write(value.total, into);
            FfiConverterInt64.write(value.reserved, into);
            FfiConverterInt64.write(value.pendingBalancesFromChannelClosures, into);
            FfiConverterArrayTypePendingBalanceDetails.write(value.pendingBalancesDetails, into);
            FfiConverterString.write(value.internalBalances, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.spendable) + 
            FfiConverterInt64.allocationSize(value.total) + 
            FfiConverterInt64.allocationSize(value.reserved) + 
            FfiConverterInt64.allocationSize(value.pendingBalancesFromChannelClosures) + 
            FfiConverterArrayTypePendingBalanceDetails.allocationSize(value.pendingBalancesDetails) + 
            FfiConverterString.allocationSize(value.internalBalances);
            
        }
    };
    return new FFIConverter();
})();


export type OpenChannelRequest = {
    pubkey: string,
    amountMsats: /*i64*/bigint,
    public_: boolean
}

/**
 * Generated factory for {@link OpenChannelRequest} record objects.
 */
export const OpenChannelRequest = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<OpenChannelRequest, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OpenChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link OpenChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<OpenChannelRequest>,
    });
})();

const FfiConverterTypeOpenChannelRequest = (() => {
    type TypeName = OpenChannelRequest;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                pubkey: FfiConverterString.read(from), 
                amountMsats: FfiConverterInt64.read(from), 
                public_: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.pubkey, into);
            FfiConverterInt64.write(value.amountMsats, into);
            FfiConverterBool.write(value.public_, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.pubkey) + 
            FfiConverterInt64.allocationSize(value.amountMsats) + 
            FfiConverterBool.allocationSize(value.public_);
            
        }
    };
    return new FFIConverter();
})();


export type OpenChannelResponse = {
    fundingTxId: string
}

/**
 * Generated factory for {@link OpenChannelResponse} record objects.
 */
export const OpenChannelResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<OpenChannelResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link OpenChannelResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link OpenChannelResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<OpenChannelResponse>,
    });
})();

const FfiConverterTypeOpenChannelResponse = (() => {
    type TypeName = OpenChannelResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                fundingTxId: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.fundingTxId, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.fundingTxId);
            
        }
    };
    return new FFIConverter();
})();


export type PayCode = {
    offerId: string,
    bolt12: string,
    label: string | undefined,
    active: boolean | undefined,
    singleUse: boolean | undefined,
    used: boolean | undefined
}

/**
 * Generated factory for {@link PayCode} record objects.
 */
export const PayCode = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PayCode, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PayCode}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PayCode}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PayCode>,
    });
})();

const FfiConverterTypePayCode = (() => {
    type TypeName = PayCode;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                offerId: FfiConverterString.read(from), 
                bolt12: FfiConverterString.read(from), 
                label: FfiConverterOptionalString.read(from), 
                active: FfiConverterOptionalBool.read(from), 
                singleUse: FfiConverterOptionalBool.read(from), 
                used: FfiConverterOptionalBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.offerId, into);
            FfiConverterString.write(value.bolt12, into);
            FfiConverterOptionalString.write(value.label, into);
            FfiConverterOptionalBool.write(value.active, into);
            FfiConverterOptionalBool.write(value.singleUse, into);
            FfiConverterOptionalBool.write(value.used, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.offerId) + 
            FfiConverterString.allocationSize(value.bolt12) + 
            FfiConverterOptionalString.allocationSize(value.label) + 
            FfiConverterOptionalBool.allocationSize(value.active) + 
            FfiConverterOptionalBool.allocationSize(value.singleUse) + 
            FfiConverterOptionalBool.allocationSize(value.used);
            
        }
    };
    return new FFIConverter();
})();


export type PayInvoiceParams = {
    invoice: string,
    feeLimitMsat: /*i64*/bigint | undefined,
    feeLimitPercentage: /*f64*/number | undefined,
    timeoutSeconds: /*i64*/bigint | undefined,
    amountMsats: /*i64*/bigint | undefined,
    maxParts: /*i64*/bigint | undefined,
    firstHopPubkey: string | undefined,
    lastHopPubkey: string | undefined,
    allowSelfPayment: boolean | undefined,
    isAmp: boolean | undefined
}

/**
 * Generated factory for {@link PayInvoiceParams} record objects.
 */
export const PayInvoiceParams = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PayInvoiceParams, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PayInvoiceParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PayInvoiceParams}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PayInvoiceParams>,
    });
})();

const FfiConverterTypePayInvoiceParams = (() => {
    type TypeName = PayInvoiceParams;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                invoice: FfiConverterString.read(from), 
                feeLimitMsat: FfiConverterOptionalInt64.read(from), 
                feeLimitPercentage: FfiConverterOptionalFloat64.read(from), 
                timeoutSeconds: FfiConverterOptionalInt64.read(from), 
                amountMsats: FfiConverterOptionalInt64.read(from), 
                maxParts: FfiConverterOptionalInt64.read(from), 
                firstHopPubkey: FfiConverterOptionalString.read(from), 
                lastHopPubkey: FfiConverterOptionalString.read(from), 
                allowSelfPayment: FfiConverterOptionalBool.read(from), 
                isAmp: FfiConverterOptionalBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.invoice, into);
            FfiConverterOptionalInt64.write(value.feeLimitMsat, into);
            FfiConverterOptionalFloat64.write(value.feeLimitPercentage, into);
            FfiConverterOptionalInt64.write(value.timeoutSeconds, into);
            FfiConverterOptionalInt64.write(value.amountMsats, into);
            FfiConverterOptionalInt64.write(value.maxParts, into);
            FfiConverterOptionalString.write(value.firstHopPubkey, into);
            FfiConverterOptionalString.write(value.lastHopPubkey, into);
            FfiConverterOptionalBool.write(value.allowSelfPayment, into);
            FfiConverterOptionalBool.write(value.isAmp, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.invoice) + 
            FfiConverterOptionalInt64.allocationSize(value.feeLimitMsat) + 
            FfiConverterOptionalFloat64.allocationSize(value.feeLimitPercentage) + 
            FfiConverterOptionalInt64.allocationSize(value.timeoutSeconds) + 
            FfiConverterOptionalInt64.allocationSize(value.amountMsats) + 
            FfiConverterOptionalInt64.allocationSize(value.maxParts) + 
            FfiConverterOptionalString.allocationSize(value.firstHopPubkey) + 
            FfiConverterOptionalString.allocationSize(value.lastHopPubkey) + 
            FfiConverterOptionalBool.allocationSize(value.allowSelfPayment) + 
            FfiConverterOptionalBool.allocationSize(value.isAmp);
            
        }
    };
    return new FFIConverter();
})();


export type PayInvoiceResponse = {
    paymentHash: string,
    preimage: string,
    feeMsats: /*i64*/bigint
}

/**
 * Generated factory for {@link PayInvoiceResponse} record objects.
 */
export const PayInvoiceResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PayInvoiceResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PayInvoiceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PayInvoiceResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PayInvoiceResponse>,
    });
})();

const FfiConverterTypePayInvoiceResponse = (() => {
    type TypeName = PayInvoiceResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                paymentHash: FfiConverterString.read(from), 
                preimage: FfiConverterString.read(from), 
                feeMsats: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.paymentHash, into);
            FfiConverterString.write(value.preimage, into);
            FfiConverterInt64.write(value.feeMsats, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.paymentHash) + 
            FfiConverterString.allocationSize(value.preimage) + 
            FfiConverterInt64.allocationSize(value.feeMsats);
            
        }
    };
    return new FFIConverter();
})();


export type PayKeysendResponse = {
    fee: /*i64*/bigint
}

/**
 * Generated factory for {@link PayKeysendResponse} record objects.
 */
export const PayKeysendResponse = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PayKeysendResponse, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PayKeysendResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PayKeysendResponse}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PayKeysendResponse>,
    });
})();

const FfiConverterTypePayKeysendResponse = (() => {
    type TypeName = PayKeysendResponse;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                fee: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.fee, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.fee);
            
        }
    };
    return new FFIConverter();
})();


export type Payment = {
    paymentId: string,
    circId: string,
    round: /*i64*/bigint,
    relayFingerprint: string,
    updatedAt: /*i64*/bigint,
    amountMsats: /*i64*/bigint
}

/**
 * Generated factory for {@link Payment} record objects.
 */
export const Payment = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Payment, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Payment}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Payment}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Payment>,
    });
})();

const FfiConverterTypePayment = (() => {
    type TypeName = Payment;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                paymentId: FfiConverterString.read(from), 
                circId: FfiConverterString.read(from), 
                round: FfiConverterInt64.read(from), 
                relayFingerprint: FfiConverterString.read(from), 
                updatedAt: FfiConverterInt64.read(from), 
                amountMsats: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.paymentId, into);
            FfiConverterString.write(value.circId, into);
            FfiConverterInt64.write(value.round, into);
            FfiConverterString.write(value.relayFingerprint, into);
            FfiConverterInt64.write(value.updatedAt, into);
            FfiConverterInt64.write(value.amountMsats, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.paymentId) + 
            FfiConverterString.allocationSize(value.circId) + 
            FfiConverterInt64.allocationSize(value.round) + 
            FfiConverterString.allocationSize(value.relayFingerprint) + 
            FfiConverterInt64.allocationSize(value.updatedAt) + 
            FfiConverterInt64.allocationSize(value.amountMsats);
            
        }
    };
    return new FFIConverter();
})();


export type PaymentFailedEventProperties = {
    transaction: Transaction,
    reason: string
}

/**
 * Generated factory for {@link PaymentFailedEventProperties} record objects.
 */
export const PaymentFailedEventProperties = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PaymentFailedEventProperties, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PaymentFailedEventProperties}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PaymentFailedEventProperties}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PaymentFailedEventProperties>,
    });
})();

const FfiConverterTypePaymentFailedEventProperties = (() => {
    type TypeName = PaymentFailedEventProperties;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                transaction: FfiConverterTypeTransaction.read(from), 
                reason: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterTypeTransaction.write(value.transaction, into);
            FfiConverterString.write(value.reason, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterTypeTransaction.allocationSize(value.transaction) + 
            FfiConverterString.allocationSize(value.reason);
            
        }
    };
    return new FFIConverter();
})();


export type PeerDetails = {
    nodeId: string,
    address: string,
    isPersisted: boolean,
    isConnected: boolean
}

/**
 * Generated factory for {@link PeerDetails} record objects.
 */
export const PeerDetails = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PeerDetails, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PeerDetails}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PeerDetails}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PeerDetails>,
    });
})();

const FfiConverterTypePeerDetails = (() => {
    type TypeName = PeerDetails;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                nodeId: FfiConverterString.read(from), 
                address: FfiConverterString.read(from), 
                isPersisted: FfiConverterBool.read(from), 
                isConnected: FfiConverterBool.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.nodeId, into);
            FfiConverterString.write(value.address, into);
            FfiConverterBool.write(value.isPersisted, into);
            FfiConverterBool.write(value.isConnected, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.nodeId) + 
            FfiConverterString.allocationSize(value.address) + 
            FfiConverterBool.allocationSize(value.isPersisted) + 
            FfiConverterBool.allocationSize(value.isConnected);
            
        }
    };
    return new FFIConverter();
})();


export type PendingBalanceDetails = {
    channelId: string,
    nodeId: string,
    amountMsats: /*i64*/bigint,
    fundingTxId: string,
    fundingTxVout: /*i64*/bigint
}

/**
 * Generated factory for {@link PendingBalanceDetails} record objects.
 */
export const PendingBalanceDetails = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PendingBalanceDetails, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PendingBalanceDetails}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PendingBalanceDetails}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PendingBalanceDetails>,
    });
})();

const FfiConverterTypePendingBalanceDetails = (() => {
    type TypeName = PendingBalanceDetails;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                channelId: FfiConverterString.read(from), 
                nodeId: FfiConverterString.read(from), 
                amountMsats: FfiConverterInt64.read(from), 
                fundingTxId: FfiConverterString.read(from), 
                fundingTxVout: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.channelId, into);
            FfiConverterString.write(value.nodeId, into);
            FfiConverterInt64.write(value.amountMsats, into);
            FfiConverterString.write(value.fundingTxId, into);
            FfiConverterInt64.write(value.fundingTxVout, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.channelId) + 
            FfiConverterString.allocationSize(value.nodeId) + 
            FfiConverterInt64.allocationSize(value.amountMsats) + 
            FfiConverterString.allocationSize(value.fundingTxId) + 
            FfiConverterInt64.allocationSize(value.fundingTxVout);
            
        }
    };
    return new FFIConverter();
})();


export type PhoenixdConfig = {
    url: string,
    password: string
}

/**
 * Generated factory for {@link PhoenixdConfig} record objects.
 */
export const PhoenixdConfig = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<PhoenixdConfig, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link PhoenixdConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link PhoenixdConfig}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<PhoenixdConfig>,
    });
})();

const FfiConverterTypePhoenixdConfig = (() => {
    type TypeName = PhoenixdConfig;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                url: FfiConverterString.read(from), 
                password: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.url, into);
            FfiConverterString.write(value.password, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.url) + 
            FfiConverterString.allocationSize(value.password);
            
        }
    };
    return new FFIConverter();
})();


export type TlvRecord = {
    type: /*i64*/bigint,
    value: string
}

/**
 * Generated factory for {@link TlvRecord} record objects.
 */
export const TlvRecord = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<TlvRecord, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link TlvRecord}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link TlvRecord}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<TlvRecord>,
    });
})();

const FfiConverterTypeTLVRecord = (() => {
    type TypeName = TlvRecord;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                type: FfiConverterInt64.read(from), 
                value: FfiConverterString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterInt64.write(value.type, into);
            FfiConverterString.write(value.value, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterInt64.allocationSize(value.type) + 
            FfiConverterString.allocationSize(value.value);
            
        }
    };
    return new FFIConverter();
})();


export type Transaction = {
    type: string,
    invoice: string,
    description: string,
    descriptionHash: string,
    preimage: string,
    paymentHash: string,
    amountMsats: /*i64*/bigint,
    feesPaid: /*i64*/bigint,
    createdAt: /*i64*/bigint,
    expiresAt: /*i64*/bigint,
    settledAt: /*i64*/bigint,
    payerNote: string | undefined,
    externalId: string | undefined
}

/**
 * Generated factory for {@link Transaction} record objects.
 */
export const Transaction = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<Transaction, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link Transaction}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link Transaction}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<Transaction>,
    });
})();

const FfiConverterTypeTransaction = (() => {
    type TypeName = Transaction;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                type: FfiConverterString.read(from), 
                invoice: FfiConverterString.read(from), 
                description: FfiConverterString.read(from), 
                descriptionHash: FfiConverterString.read(from), 
                preimage: FfiConverterString.read(from), 
                paymentHash: FfiConverterString.read(from), 
                amountMsats: FfiConverterInt64.read(from), 
                feesPaid: FfiConverterInt64.read(from), 
                createdAt: FfiConverterInt64.read(from), 
                expiresAt: FfiConverterInt64.read(from), 
                settledAt: FfiConverterInt64.read(from), 
                payerNote: FfiConverterOptionalString.read(from), 
                externalId: FfiConverterOptionalString.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.type, into);
            FfiConverterString.write(value.invoice, into);
            FfiConverterString.write(value.description, into);
            FfiConverterString.write(value.descriptionHash, into);
            FfiConverterString.write(value.preimage, into);
            FfiConverterString.write(value.paymentHash, into);
            FfiConverterInt64.write(value.amountMsats, into);
            FfiConverterInt64.write(value.feesPaid, into);
            FfiConverterInt64.write(value.createdAt, into);
            FfiConverterInt64.write(value.expiresAt, into);
            FfiConverterInt64.write(value.settledAt, into);
            FfiConverterOptionalString.write(value.payerNote, into);
            FfiConverterOptionalString.write(value.externalId, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.type) + 
            FfiConverterString.allocationSize(value.invoice) + 
            FfiConverterString.allocationSize(value.description) + 
            FfiConverterString.allocationSize(value.descriptionHash) + 
            FfiConverterString.allocationSize(value.preimage) + 
            FfiConverterString.allocationSize(value.paymentHash) + 
            FfiConverterInt64.allocationSize(value.amountMsats) + 
            FfiConverterInt64.allocationSize(value.feesPaid) + 
            FfiConverterInt64.allocationSize(value.createdAt) + 
            FfiConverterInt64.allocationSize(value.expiresAt) + 
            FfiConverterInt64.allocationSize(value.settledAt) + 
            FfiConverterOptionalString.allocationSize(value.payerNote) + 
            FfiConverterOptionalString.allocationSize(value.externalId);
            
        }
    };
    return new FFIConverter();
})();


export type UpdateChannelRequest = {
    channelId: string,
    nodeId: string,
    forwardingFeeBaseMsat: /*i64*/bigint,
    maxDustHtlcExposureFromFeeRateMultiplier: /*i64*/bigint
}

/**
 * Generated factory for {@link UpdateChannelRequest} record objects.
 */
export const UpdateChannelRequest = (() => {
    const defaults = () => ({
    });
    const create = (() => {
        return uniffiCreateRecord<UpdateChannelRequest, ReturnType<typeof defaults>>(defaults);
    })();
    return Object.freeze({
        /**
         * Create a frozen instance of {@link UpdateChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        create,

        /**
         * Create a frozen instance of {@link UpdateChannelRequest}, with defaults specified
         * in Rust, in the {@link lni} crate.
         */
        new: create,

        /**
         * Defaults specified in the {@link lni} crate.
         */
        defaults: () => Object.freeze(defaults()) as Partial<UpdateChannelRequest>,
    });
})();

const FfiConverterTypeUpdateChannelRequest = (() => {
    type TypeName = UpdateChannelRequest;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            return {
                channelId: FfiConverterString.read(from), 
                nodeId: FfiConverterString.read(from), 
                forwardingFeeBaseMsat: FfiConverterInt64.read(from), 
                maxDustHtlcExposureFromFeeRateMultiplier: FfiConverterInt64.read(from)
            };
        }
        write(value: TypeName, into: RustBuffer): void {
            FfiConverterString.write(value.channelId, into);
            FfiConverterString.write(value.nodeId, into);
            FfiConverterInt64.write(value.forwardingFeeBaseMsat, into);
            FfiConverterInt64.write(value.maxDustHtlcExposureFromFeeRateMultiplier, into);
        }
        allocationSize(value: TypeName): number {
            return FfiConverterString.allocationSize(value.channelId) + 
            FfiConverterString.allocationSize(value.nodeId) + 
            FfiConverterInt64.allocationSize(value.forwardingFeeBaseMsat) + 
            FfiConverterInt64.allocationSize(value.maxDustHtlcExposureFromFeeRateMultiplier);
            
        }
    };
    return new FFIConverter();
})();


const stringConverter = {
    stringToBytes: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(s, status)),
    bytesToString: (ab: UniffiByteArray) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(ab, status)),
    stringByteLength: (s: string) =>
        uniffiCaller.rustCall((status) => nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(s, status)),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);




// Error type: ApiError

// Enum: ApiError
export enum ApiError_Tags {
    Http = "Http",
    Api = "Api",
    Json = "Json"
}
export const ApiError = (() => {
    

    type Http__interface = {
        tag: ApiError_Tags.Http;
        inner: Readonly<{reason: string}>
    };

    
    class Http_ extends UniffiError implements Http__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ApiError";
        readonly tag = ApiError_Tags.Http;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("ApiError", "Http");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): Http_ {
            return new Http_(inner);
        }

        static instanceOf(obj: any): obj is Http_ {
            return obj.tag === ApiError_Tags.Http;
        }

        
        static hasInner(obj: any): obj is Http_ {
            return Http_.instanceOf(obj);
        }

        static getInner(obj: Http_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }
    

    type Api__interface = {
        tag: ApiError_Tags.Api;
        inner: Readonly<{reason: string}>
    };

    
    class Api_ extends UniffiError implements Api__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ApiError";
        readonly tag = ApiError_Tags.Api;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("ApiError", "Api");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): Api_ {
            return new Api_(inner);
        }

        static instanceOf(obj: any): obj is Api_ {
            return obj.tag === ApiError_Tags.Api;
        }

        
        static hasInner(obj: any): obj is Api_ {
            return Api_.instanceOf(obj);
        }

        static getInner(obj: Api_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }
    

    type Json__interface = {
        tag: ApiError_Tags.Json;
        inner: Readonly<{reason: string}>
    };

    
    class Json_ extends UniffiError implements Json__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "ApiError";
        readonly tag = ApiError_Tags.Json;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("ApiError", "Json");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): Json_ {
            return new Json_(inner);
        }

        static instanceOf(obj: any): obj is Json_ {
            return obj.tag === ApiError_Tags.Json;
        }

        
        static hasInner(obj: any): obj is Json_ {
            return Json_.instanceOf(obj);
        }

        static getInner(obj: Json_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }

    function instanceOf(obj: any): obj is ApiError {
        return obj[uniffiTypeNameSymbol] === "ApiError";
    }

    return Object.freeze({
        instanceOf,
  Http: Http_, 
  Api: Api_, 
  Json: Json_
    });

})();



export type ApiError = InstanceType<
    typeof ApiError[keyof Omit<typeof ApiError, 'instanceOf'>]
>;

// FfiConverter for enum ApiError
const FfiConverterTypeApiError = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = ApiError;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new ApiError.Http({reason: FfiConverterString.read(from) });
                case 2: return new ApiError.Api({reason: FfiConverterString.read(from) });
                case 3: return new ApiError.Json({reason: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case ApiError_Tags.Http: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                case ApiError_Tags.Api: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                case ApiError_Tags.Json: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                default:
                    // Throwing from here means that ApiError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case ApiError_Tags.Http: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                case ApiError_Tags.Api: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                case ApiError_Tags.Json: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();


// Error type: DbError

// Enum: DbError
export enum DbError_Tags {
    IoErr = "IoErr",
    SerializationErr = "SerializationErr",
    DeserializationErr = "DeserializationErr"
}
export const DbError = (() => {
    

    type IoErr__interface = {
        tag: DbError_Tags.IoErr;
        inner: Readonly<{reason: string}>
    };

    
    class IoErr_ extends UniffiError implements IoErr__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "DbError";
        readonly tag = DbError_Tags.IoErr;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("DbError", "IoErr");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): IoErr_ {
            return new IoErr_(inner);
        }

        static instanceOf(obj: any): obj is IoErr_ {
            return obj.tag === DbError_Tags.IoErr;
        }

        
        static hasInner(obj: any): obj is IoErr_ {
            return IoErr_.instanceOf(obj);
        }

        static getInner(obj: IoErr_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }
    

    type SerializationErr__interface = {
        tag: DbError_Tags.SerializationErr;
        inner: Readonly<{reason: string}>
    };

    
    class SerializationErr_ extends UniffiError implements SerializationErr__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "DbError";
        readonly tag = DbError_Tags.SerializationErr;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("DbError", "SerializationErr");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): SerializationErr_ {
            return new SerializationErr_(inner);
        }

        static instanceOf(obj: any): obj is SerializationErr_ {
            return obj.tag === DbError_Tags.SerializationErr;
        }

        
        static hasInner(obj: any): obj is SerializationErr_ {
            return SerializationErr_.instanceOf(obj);
        }

        static getInner(obj: SerializationErr_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }
    

    type DeserializationErr__interface = {
        tag: DbError_Tags.DeserializationErr;
        inner: Readonly<{reason: string}>
    };

    
    class DeserializationErr_ extends UniffiError implements DeserializationErr__interface {
        /**
         * @private
         * This field is private and should not be used, use `tag` instead.
         */
        readonly [uniffiTypeNameSymbol] = "DbError";
        readonly tag = DbError_Tags.DeserializationErr;
        readonly inner: Readonly<{reason: string}>;
        constructor(inner: { reason: string }) {
            super("DbError", "DeserializationErr");
            this.inner = Object.freeze(inner);
        }

        static new(inner: { reason: string }): DeserializationErr_ {
            return new DeserializationErr_(inner);
        }

        static instanceOf(obj: any): obj is DeserializationErr_ {
            return obj.tag === DbError_Tags.DeserializationErr;
        }

        
        static hasInner(obj: any): obj is DeserializationErr_ {
            return DeserializationErr_.instanceOf(obj);
        }

        static getInner(obj: DeserializationErr_): Readonly<{reason: string}> {
            return obj.inner;
        }

    }

    function instanceOf(obj: any): obj is DbError {
        return obj[uniffiTypeNameSymbol] === "DbError";
    }

    return Object.freeze({
        instanceOf,
  IoErr: IoErr_, 
  SerializationErr: SerializationErr_, 
  DeserializationErr: DeserializationErr_
    });

})();



export type DbError = InstanceType<
    typeof DbError[keyof Omit<typeof DbError, 'instanceOf'>]
>;

// FfiConverter for enum DbError
const FfiConverterTypeDbError = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = DbError;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return new DbError.IoErr({reason: FfiConverterString.read(from) });
                case 2: return new DbError.SerializationErr({reason: FfiConverterString.read(from) });
                case 3: return new DbError.DeserializationErr({reason: FfiConverterString.read(from) });
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value.tag) {
                case DbError_Tags.IoErr: {
                    ordinalConverter.write(1, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                case DbError_Tags.SerializationErr: {
                    ordinalConverter.write(2, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                case DbError_Tags.DeserializationErr: {
                    ordinalConverter.write(3, into);
                    const inner = value.inner;
                    FfiConverterString.write(inner.reason, into);
                    return;
                }
                default:
                    // Throwing from here means that DbError_Tags hasn't matched an ordinal.
                    throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        allocationSize(value: TypeName): number {
            switch (value.tag) {
                case DbError_Tags.IoErr: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(1);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                case DbError_Tags.SerializationErr: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(2);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                case DbError_Tags.DeserializationErr: {
                    const inner = value.inner;
                    let size = ordinalConverter.allocationSize(3);
                    size += FfiConverterString.allocationSize(inner.reason);
                    return size;
                }
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
    }
    return new FFIConverter();
})();


export enum InvoiceType {
    Bolt11,
    Bolt12
}

const FfiConverterTypeInvoiceType = (() => {
    const ordinalConverter = FfiConverterInt32;
    type TypeName = InvoiceType;
    class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
        read(from: RustBuffer): TypeName {
            switch (ordinalConverter.read(from)) {
                case 1: return InvoiceType.Bolt11;
                case 2: return InvoiceType.Bolt12;
                default: throw new UniffiInternalError.UnexpectedEnumCase();
            }
        }
        write(value: TypeName, into: RustBuffer): void {
            switch (value) {
                case InvoiceType.Bolt11: return ordinalConverter.write(1, into);
                case InvoiceType.Bolt12: return ordinalConverter.write(2, into);
            }
        }
        allocationSize(value: TypeName): number {
            return ordinalConverter.allocationSize(0);
        }
    }
    return new FFIConverter();
})();





export interface ClnNodeInterface {
    
    createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    decode(str: string, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<string>;
    getInfo(asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<NodeInfo>;
    getOffer(search: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayCode>;
    listOffers(search: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Array<PayCode>>;
    listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Array<Transaction>>;
    lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
    payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
}


export class ClnNode extends UniffiAbstractObject implements ClnNodeInterface {

    readonly [uniffiTypeNameSymbol] = "ClnNode";
    readonly [destructorGuardSymbol]: UniffiRustArcPtr;
    readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
    constructor(config: ClnConfig) {
        super();
        const pointer =
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_constructor_clnnode_new(
        FfiConverterTypeClnConfig.lower(config),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeClnNodeObjectFactory.bless(pointer);
    }

    

    
async public createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_create_invoice(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeCreateInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public decode(str: string, asyncOpts_?: { signal: AbortSignal }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_decode(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(str)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getInfo(asyncOpts_?: { signal: AbortSignal }): Promise<NodeInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_get_info(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this)
                    
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeNodeInfo.lift.bind(FfiConverterTypeNodeInfo),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getOffer(search: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<PayCode> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_get_offer(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterOptionalString.lower(search)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayCode.lift.bind(FfiConverterTypePayCode),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public listOffers(search: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<Array<PayCode>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_list_offers(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterOptionalString.lower(search)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterArrayTypePayCode.lift.bind(FfiConverterArrayTypePayCode),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal }): Promise<Array<Transaction>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_list_transactions(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeListTransactionsParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterArrayTypeTransaction.lift.bind(FfiConverterArrayTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_lookup_invoice(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(paymentHash)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_pay_invoice(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterTypePayInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_clnnode_pay_offer(
                    uniffiTypeClnNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionalString.lower(payerNote)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    

    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy(): void {
        const ptr = (this as any)[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeClnNodeObjectFactory.pointer(this);
            uniffiTypeClnNodeObjectFactory.freePointer(pointer);
            uniffiTypeClnNodeObjectFactory.unbless(ptr);
            delete (this as any)[destructorGuardSymbol];
        }
    }

    static instanceOf(obj: any): obj is ClnNode {
        return uniffiTypeClnNodeObjectFactory.isConcreteType(obj);
    }

    
}

const uniffiTypeClnNodeObjectFactory: UniffiObjectFactory<ClnNodeInterface> = {
    create(pointer: UnsafeMutableRawPointer): ClnNodeInterface {
        const instance = Object.create(ClnNode.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "ClnNode";
        return instance;
    },

    
    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
            /*caller:*/ (status) =>
                nativeModule().ubrn_uniffi_internal_fn_method_clnnode_ffi__bless_pointer(p, status),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
    },

    pointer(obj: ClnNodeInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
            throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ClnNodeInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_clone_clnnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_free_clnnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    isConcreteType(obj: any): obj is ClnNodeInterface {
        return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "ClnNode";
    },
};
// FfiConverter for ClnNodeInterface
const FfiConverterTypeClnNode =  new FfiConverterObject(uniffiTypeClnNodeObjectFactory);


export interface DbInterface {
    
    lookupPayment(paymentId: string)  /*throws*/: Payment | undefined;
    save()  /*throws*/: void;
    writePayment(payment: Payment)  /*throws*/: void;
}


export class Db extends UniffiAbstractObject implements DbInterface {

    readonly [uniffiTypeNameSymbol] = "Db";
    readonly [destructorGuardSymbol]: UniffiRustArcPtr;
    readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
    constructor(path: string) /*throws*/ {
        super();
        const pointer =
            
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDbError.lift.bind(FfiConverterTypeDbError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_constructor_db_new(
        FfiConverterString.lower(path),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeDbObjectFactory.bless(pointer);
    }

    

    
public lookupPayment(paymentId: string): Payment | undefined /*throws*/ {
    return FfiConverterOptionalTypePayment.lift(
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDbError.lift.bind(FfiConverterTypeDbError),
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_db_lookup_payment(uniffiTypeDbObjectFactory.clonePointer(this), 
        FfiConverterString.lower(paymentId),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    ));
    }
    
public save(): void /*throws*/ {
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDbError.lift.bind(FfiConverterTypeDbError),
            /*caller:*/ (callStatus) => { nativeModule().ubrn_uniffi_lni_uniffi_fn_method_db_save(uniffiTypeDbObjectFactory.clonePointer(this), 
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
    }
    
public writePayment(payment: Payment): void /*throws*/ {
        uniffiCaller.rustCallWithError(
            /*liftError:*/ FfiConverterTypeDbError.lift.bind(FfiConverterTypeDbError),
            /*caller:*/ (callStatus) => { nativeModule().ubrn_uniffi_lni_uniffi_fn_method_db_write_payment(uniffiTypeDbObjectFactory.clonePointer(this), 
        FfiConverterTypePayment.lower(payment),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
    }
    

    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy(): void {
        const ptr = (this as any)[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeDbObjectFactory.pointer(this);
            uniffiTypeDbObjectFactory.freePointer(pointer);
            uniffiTypeDbObjectFactory.unbless(ptr);
            delete (this as any)[destructorGuardSymbol];
        }
    }

    static instanceOf(obj: any): obj is Db {
        return uniffiTypeDbObjectFactory.isConcreteType(obj);
    }

    
}

const uniffiTypeDbObjectFactory: UniffiObjectFactory<DbInterface> = {
    create(pointer: UnsafeMutableRawPointer): DbInterface {
        const instance = Object.create(Db.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "Db";
        return instance;
    },

    
    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
            /*caller:*/ (status) =>
                nativeModule().ubrn_uniffi_internal_fn_method_db_ffi__bless_pointer(p, status),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
    },

    pointer(obj: DbInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
            throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: DbInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_clone_db(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_free_db(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    isConcreteType(obj: any): obj is DbInterface {
        return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Db";
    },
};
// FfiConverter for DbInterface
const FfiConverterTypeDb =  new FfiConverterObject(uniffiTypeDbObjectFactory);


export interface LndNodeInterface {
    
    createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    decode(str: string, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<string>;
    getInfo(asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<NodeInfo>;
    getOffer(search: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayCode>;
    listOffers(search: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Array<PayCode>>;
    listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Array<Transaction>>;
    lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
    payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
}


export class LndNode extends UniffiAbstractObject implements LndNodeInterface {

    readonly [uniffiTypeNameSymbol] = "LndNode";
    readonly [destructorGuardSymbol]: UniffiRustArcPtr;
    readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
    constructor(config: LndConfig) {
        super();
        const pointer =
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_constructor_lndnode_new(
        FfiConverterTypeLndConfig.lower(config),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypeLndNodeObjectFactory.bless(pointer);
    }

    

    
async public createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_create_invoice(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeCreateInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public decode(str: string, asyncOpts_?: { signal: AbortSignal }): Promise<string> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_decode(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(str)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterString.lift.bind(FfiConverterString),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getInfo(asyncOpts_?: { signal: AbortSignal }): Promise<NodeInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_get_info(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this)
                    
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeNodeInfo.lift.bind(FfiConverterTypeNodeInfo),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getOffer(search: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<PayCode> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_get_offer(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterOptionalString.lower(search)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayCode.lift.bind(FfiConverterTypePayCode),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public listOffers(search: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<Array<PayCode>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_list_offers(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterOptionalString.lower(search)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterArrayTypePayCode.lift.bind(FfiConverterArrayTypePayCode),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal }): Promise<Array<Transaction>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_list_transactions(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeListTransactionsParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterArrayTypeTransaction.lift.bind(FfiConverterArrayTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_lookup_invoice(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(paymentHash)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_pay_invoice(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterTypePayInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_lndnode_pay_offer(
                    uniffiTypeLndNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionalString.lower(payerNote)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    

    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy(): void {
        const ptr = (this as any)[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypeLndNodeObjectFactory.pointer(this);
            uniffiTypeLndNodeObjectFactory.freePointer(pointer);
            uniffiTypeLndNodeObjectFactory.unbless(ptr);
            delete (this as any)[destructorGuardSymbol];
        }
    }

    static instanceOf(obj: any): obj is LndNode {
        return uniffiTypeLndNodeObjectFactory.isConcreteType(obj);
    }

    
}

const uniffiTypeLndNodeObjectFactory: UniffiObjectFactory<LndNodeInterface> = {
    create(pointer: UnsafeMutableRawPointer): LndNodeInterface {
        const instance = Object.create(LndNode.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "LndNode";
        return instance;
    },

    
    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
            /*caller:*/ (status) =>
                nativeModule().ubrn_uniffi_internal_fn_method_lndnode_ffi__bless_pointer(p, status),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
    },

    pointer(obj: LndNodeInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
            throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LndNodeInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_clone_lndnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_free_lndnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    isConcreteType(obj: any): obj is LndNodeInterface {
        return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "LndNode";
    },
};
// FfiConverter for LndNodeInterface
const FfiConverterTypeLndNode =  new FfiConverterObject(uniffiTypeLndNodeObjectFactory);


export interface PhoenixdNodeInterface {
    
    createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    getInfo(asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<NodeInfo>;
    getOffer(asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayCode>;
    listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Array<Transaction>>;
    lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<Transaction>;
    payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
    payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal })  /*throws*/: Promise<PayInvoiceResponse>;
}


export class PhoenixdNode extends UniffiAbstractObject implements PhoenixdNodeInterface {

    readonly [uniffiTypeNameSymbol] = "PhoenixdNode";
    readonly [destructorGuardSymbol]: UniffiRustArcPtr;
    readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
    constructor(config: PhoenixdConfig) {
        super();
        const pointer =
            uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_constructor_phoenixdnode_new(
        FfiConverterTypePhoenixdConfig.lower(config),
                callStatus);
            },
            /*liftString:*/ FfiConverterString.lift,
    );
        this[pointerLiteralSymbol] = pointer;
        this[destructorGuardSymbol] = uniffiTypePhoenixdNodeObjectFactory.bless(pointer);
    }

    

    
async public createInvoice(params: CreateInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_create_invoice(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeCreateInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getInfo(asyncOpts_?: { signal: AbortSignal }): Promise<NodeInfo> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_get_info(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this)
                    
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeNodeInfo.lift.bind(FfiConverterTypeNodeInfo),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public getOffer(asyncOpts_?: { signal: AbortSignal }): Promise<PayCode> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_get_offer(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this)
                    
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayCode.lift.bind(FfiConverterTypePayCode),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public listTransactions(params: ListTransactionsParams, asyncOpts_?: { signal: AbortSignal }): Promise<Array<Transaction>> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_list_transactions(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this),
                    FfiConverterTypeListTransactionsParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterArrayTypeTransaction.lift.bind(FfiConverterArrayTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public lookupInvoice(paymentHash: string, asyncOpts_?: { signal: AbortSignal }): Promise<Transaction> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_lookup_invoice(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(paymentHash)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypeTransaction.lift.bind(FfiConverterTypeTransaction),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payInvoice(params: PayInvoiceParams, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_pay_invoice(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this),
                    FfiConverterTypePayInvoiceParams.lower(params)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    
async public payOffer(offer: string, amountMsats: /*i64*/bigint, payerNote: string | undefined, asyncOpts_?: { signal: AbortSignal }): Promise<PayInvoiceResponse> /*throws*/ {
    const __stack = uniffiIsDebug ? new Error().stack : undefined;
    try {
        return await uniffiRustCallAsync(
            /*rustCaller:*/ uniffiCaller,
            /*rustFutureFunc:*/ () => {
                return nativeModule().ubrn_uniffi_lni_uniffi_fn_method_phoenixdnode_pay_offer(
                    uniffiTypePhoenixdNodeObjectFactory.clonePointer(this),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionalString.lower(payerNote)
                );
            },
            /*pollFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_poll_rust_buffer,
            /*cancelFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_cancel_rust_buffer,
            /*completeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_complete_rust_buffer,
            /*freeFunc:*/ nativeModule().ubrn_ffi_lni_uniffi_rust_future_free_rust_buffer,
            /*liftFunc:*/ FfiConverterTypePayInvoiceResponse.lift.bind(FfiConverterTypePayInvoiceResponse),
            /*liftString:*/ FfiConverterString.lift,
            /*asyncOpts:*/ asyncOpts_,
            /*errorHandler:*/ FfiConverterTypeApiError.lift.bind(FfiConverterTypeApiError)
        );
    } catch (__error: any) {
        if (uniffiIsDebug && __error instanceof Error) {
            __error.stack = __stack;
        }
        throw __error;
    }
    }
    

    /**
     * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
     */
    uniffiDestroy(): void {
        const ptr = (this as any)[destructorGuardSymbol];
        if (ptr !== undefined) {
            const pointer = uniffiTypePhoenixdNodeObjectFactory.pointer(this);
            uniffiTypePhoenixdNodeObjectFactory.freePointer(pointer);
            uniffiTypePhoenixdNodeObjectFactory.unbless(ptr);
            delete (this as any)[destructorGuardSymbol];
        }
    }

    static instanceOf(obj: any): obj is PhoenixdNode {
        return uniffiTypePhoenixdNodeObjectFactory.isConcreteType(obj);
    }

    
}

const uniffiTypePhoenixdNodeObjectFactory: UniffiObjectFactory<PhoenixdNodeInterface> = {
    create(pointer: UnsafeMutableRawPointer): PhoenixdNodeInterface {
        const instance = Object.create(PhoenixdNode.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "PhoenixdNode";
        return instance;
    },

    
    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
            /*caller:*/ (status) =>
                nativeModule().ubrn_uniffi_internal_fn_method_phoenixdnode_ffi__bless_pointer(p, status),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
    },

    pointer(obj: PhoenixdNodeInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
            throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PhoenixdNodeInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_clone_phoenixdnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
            /*caller:*/ (callStatus) => nativeModule().ubrn_uniffi_lni_uniffi_fn_free_phoenixdnode(pointer, callStatus),
            /*liftString:*/ FfiConverterString.lift
        );
    },

    isConcreteType(obj: any): obj is PhoenixdNodeInterface {
        return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "PhoenixdNode";
    },
};
// FfiConverter for PhoenixdNodeInterface
const FfiConverterTypePhoenixdNode =  new FfiConverterObject(uniffiTypePhoenixdNodeObjectFactory);


// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);


// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(FfiConverterFloat64);


// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);


// FfiConverter for Payment | undefined
const FfiConverterOptionalTypePayment = new FfiConverterOptional(FfiConverterTypePayment);


// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);


// FfiConverter for Array<PayCode>
const FfiConverterArrayTypePayCode = new FfiConverterArray(FfiConverterTypePayCode);


// FfiConverter for Array<PendingBalanceDetails>
const FfiConverterArrayTypePendingBalanceDetails = new FfiConverterArray(FfiConverterTypePendingBalanceDetails);


// FfiConverter for Array<Transaction>
const FfiConverterArrayTypeTransaction = new FfiConverterArray(FfiConverterTypeTransaction);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
    // Get the bindings contract version from our ComponentInterface
    const bindingsContractVersion = 29;
    // Get the scaffolding contract version by calling the into the dylib
    const scaffoldingContractVersion = nativeModule().ubrn_ffi_lni_uniffi_uniffi_contract_version();
    if (bindingsContractVersion !== scaffoldingContractVersion) {
        throw new UniffiInternalError.ContractVersionMismatch(scaffoldingContractVersion, bindingsContractVersion);
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_create_invoice() !== 7385) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_create_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_decode() !== 46829) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_decode");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_get_info() !== 58086) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_get_info");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_get_offer() !== 41985) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_get_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_list_offers() !== 1842) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_list_offers");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_list_transactions() !== 34600) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_list_transactions");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_lookup_invoice() !== 20479) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_lookup_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_pay_invoice() !== 45383) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_pay_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_clnnode_pay_offer() !== 19135) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_clnnode_pay_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_db_lookup_payment() !== 32098) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_db_lookup_payment");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_db_save() !== 5005) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_db_save");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_db_write_payment() !== 56419) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_db_write_payment");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_create_invoice() !== 50320) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_create_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_decode() !== 63129) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_decode");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_get_info() !== 13575) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_get_info");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_get_offer() !== 57955) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_get_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_list_offers() !== 25577) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_list_offers");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_list_transactions() !== 31278) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_list_transactions");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_lookup_invoice() !== 23682) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_lookup_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_pay_invoice() !== 57203) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_pay_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_lndnode_pay_offer() !== 33027) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_lndnode_pay_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_create_invoice() !== 8468) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_create_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_get_info() !== 26496) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_get_info");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_get_offer() !== 19372) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_get_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_list_transactions() !== 10377) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_list_transactions");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_lookup_invoice() !== 53708) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_lookup_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_pay_invoice() !== 56537) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_pay_invoice");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_method_phoenixdnode_pay_offer() !== 51147) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_method_phoenixdnode_pay_offer");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_constructor_clnnode_new() !== 7618) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_constructor_clnnode_new");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_constructor_db_new() !== 40163) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_constructor_db_new");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_constructor_lndnode_new() !== 64807) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_constructor_lndnode_new");
    }
    if (nativeModule().ubrn_uniffi_lni_uniffi_checksum_constructor_phoenixdnode_new() !== 18812) {
        throw new UniffiInternalError.ApiChecksumMismatch("uniffi_lni_uniffi_checksum_constructor_phoenixdnode_new");
    }

    }

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBalancesResponse,
    FfiConverterTypeChannel,
    FfiConverterTypeClnConfig,
    FfiConverterTypeClnNode,
    FfiConverterTypeCloseChannelRequest,
    FfiConverterTypeCloseChannelResponse,
    FfiConverterTypeConnectPeerRequest,
    FfiConverterTypeCreateInvoiceParams,
    FfiConverterTypeDb,
    FfiConverterTypeInvoiceType,
    FfiConverterTypeLightningBalanceResponse,
    FfiConverterTypeListTransactionsParams,
    FfiConverterTypeLndConfig,
    FfiConverterTypeLndNode,
    FfiConverterTypeNodeConnectionInfo,
    FfiConverterTypeNodeInfo,
    FfiConverterTypeNodeStatus,
    FfiConverterTypeOnchainBalanceResponse,
    FfiConverterTypeOpenChannelRequest,
    FfiConverterTypeOpenChannelResponse,
    FfiConverterTypePayCode,
    FfiConverterTypePayInvoiceParams,
    FfiConverterTypePayInvoiceResponse,
    FfiConverterTypePayKeysendResponse,
    FfiConverterTypePayment,
    FfiConverterTypePaymentFailedEventProperties,
    FfiConverterTypePeerDetails,
    FfiConverterTypePendingBalanceDetails,
    FfiConverterTypePhoenixdConfig,
    FfiConverterTypePhoenixdNode,
    FfiConverterTypeTLVRecord,
    FfiConverterTypeTransaction,
    FfiConverterTypeUpdateChannelRequest,
  }
});