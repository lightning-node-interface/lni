// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(lniFFI)
import lniFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_lni_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_lni_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureLniInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




public protocol BlinkNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class BlinkNode: BlinkNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_blinknode(self.pointer, $0) }
    }
public convenience init(config: BlinkConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_blinknode_new(
        FfiConverterTypeBlinkConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_blinknode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_blinknode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlinkNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlinkNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlinkNode {
        return BlinkNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlinkNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlinkNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlinkNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlinkNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlinkNode {
    return try FfiConverterTypeBlinkNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlinkNode_lower(_ value: BlinkNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlinkNode.lower(value)
}






public protocol ClnNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class ClnNode: ClnNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_clnnode(self.pointer, $0) }
    }
public convenience init(config: ClnConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_clnnode_new(
        FfiConverterTypeClnConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_clnnode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_clnnode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClnNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClnNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClnNode {
        return ClnNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClnNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClnNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClnNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClnNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClnNode {
    return try FfiConverterTypeClnNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClnNode_lower(_ value: ClnNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClnNode.lower(value)
}






/**
 * The core LightningNode trait for polymorphic node operations.
 * This trait is exported to UniFFI, allowing Kotlin/Swift to work with
 * `Arc<dyn LightningNode>` directly without manual wrapper code.
 */
public protocol LightningNode: AnyObject, Sendable {
    
    func getInfo() async throws  -> NodeInfo
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func decode(str: String) async throws  -> String
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
}
/**
 * The core LightningNode trait for polymorphic node operations.
 * This trait is exported to UniFFI, allowing Kotlin/Swift to work with
 * `Arc<dyn LightningNode>` directly without manual wrapper code.
 */
open class LightningNodeImpl: LightningNode, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_lightningnode(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_lightningnode(pointer, $0) }
    }

    

    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lightningnode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLightningNode {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLightningNode] = [UniffiVTableCallbackInterfaceLightningNode(
        getInfo: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> NodeInfo in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getInfo(
                )
            }

            let uniffiHandleSuccess = { (returnValue: NodeInfo) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeNodeInfo_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        createInvoice: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Transaction in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.createInvoice(
                     params: try FfiConverterTypeCreateInvoiceParams_lift(params)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Transaction) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeTransaction_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        payInvoice: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PayInvoiceResponse in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.payInvoice(
                     params: try FfiConverterTypePayInvoiceParams_lift(params)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PayInvoiceResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayInvoiceResponse_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        createOffer: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Offer in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.createOffer(
                     params: try FfiConverterTypeCreateOfferParams_lift(params)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Offer) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeOffer_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        getOffer: { (
            uniffiHandle: UInt64,
            search: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Offer in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.getOffer(
                     search: try FfiConverterOptionString.lift(search)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Offer) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeOffer_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listOffers: { (
            uniffiHandle: UInt64,
            search: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Offer] in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listOffers(
                     search: try FfiConverterOptionString.lift(search)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Offer]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeOffer.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        payOffer: { (
            uniffiHandle: UInt64,
            offer: RustBuffer,
            amountMsats: Int64,
            payerNote: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> PayInvoiceResponse in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.payOffer(
                     offer: try FfiConverterString.lift(offer),
                     amountMsats: try FfiConverterInt64.lift(amountMsats),
                     payerNote: try FfiConverterOptionString.lift(payerNote)
                )
            }

            let uniffiHandleSuccess = { (returnValue: PayInvoiceResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypePayInvoiceResponse_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        lookupInvoice: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Transaction in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.lookupInvoice(
                     params: try FfiConverterTypeLookupInvoiceParams_lift(params)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Transaction) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeTransaction_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        listTransactions: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Transaction] in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.listTransactions(
                     params: try FfiConverterTypeListTransactionsParams_lift(params)
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Transaction]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeTransaction.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        decode: { (
            uniffiHandle: UInt64,
            str: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.decode(
                     str: try FfiConverterString.lift(str)
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeApiError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        onInvoiceEvents: { (
            uniffiHandle: UInt64,
            params: RustBuffer,
            callback: UnsafeMutableRawPointer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLightningNode.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.onInvoiceEvents(
                     params: try FfiConverterTypeOnInvoiceEventParams_lift(params),
                     callback: try FfiConverterTypeOnInvoiceEventCallback_lift(callback)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLightningNode.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LightningNode: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLightningNode() {
    uniffi_lni_fn_init_callback_vtable_lightningnode(UniffiCallbackInterfaceLightningNode.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningNode: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<LightningNode>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LightningNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
        return LightningNodeImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LightningNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> LightningNode {
    return try FfiConverterTypeLightningNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningNode_lower(_ value: LightningNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLightningNode.lower(value)
}






public protocol LndNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class LndNode: LndNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_lndnode(self.pointer, $0) }
    }
public convenience init(config: LndConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_lndnode_new(
        FfiConverterTypeLndConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_lndnode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_lndnode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLndNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LndNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LndNode {
        return LndNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LndNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LndNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LndNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLndNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> LndNode {
    return try FfiConverterTypeLndNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLndNode_lower(_ value: LndNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLndNode.lower(value)
}






public protocol NwcNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class NwcNode: NwcNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_nwcnode(self.pointer, $0) }
    }
public convenience init(config: NwcConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_nwcnode_new(
        FfiConverterTypeNwcConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_nwcnode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_nwcnode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNwcNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NwcNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NwcNode {
        return NwcNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NwcNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NwcNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NwcNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNwcNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> NwcNode {
    return try FfiConverterTypeNwcNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNwcNode_lower(_ value: NwcNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNwcNode.lower(value)
}






public protocol OnInvoiceEventCallback: AnyObject, Sendable {
    
    func success(transaction: Transaction?) 
    
    func pending(transaction: Transaction?) 
    
    func failure(transaction: Transaction?) 
    
}
open class OnInvoiceEventCallbackImpl: OnInvoiceEventCallback, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_oninvoiceeventcallback(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_oninvoiceeventcallback(pointer, $0) }
    }

    

    
open func success(transaction: Transaction?)  {try! rustCall() {
    uniffi_lni_fn_method_oninvoiceeventcallback_success(self.uniffiClonePointer(),
        FfiConverterOptionTypeTransaction.lower(transaction),$0
    )
}
}
    
open func pending(transaction: Transaction?)  {try! rustCall() {
    uniffi_lni_fn_method_oninvoiceeventcallback_pending(self.uniffiClonePointer(),
        FfiConverterOptionTypeTransaction.lower(transaction),$0
    )
}
}
    
open func failure(transaction: Transaction?)  {try! rustCall() {
    uniffi_lni_fn_method_oninvoiceeventcallback_failure(self.uniffiClonePointer(),
        FfiConverterOptionTypeTransaction.lower(transaction),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceOnInvoiceEventCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceOnInvoiceEventCallback] = [UniffiVTableCallbackInterfaceOnInvoiceEventCallback(
        success: { (
            uniffiHandle: UInt64,
            transaction: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOnInvoiceEventCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.success(
                     transaction: try FfiConverterOptionTypeTransaction.lift(transaction)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        pending: { (
            uniffiHandle: UInt64,
            transaction: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOnInvoiceEventCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.pending(
                     transaction: try FfiConverterOptionTypeTransaction.lift(transaction)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        failure: { (
            uniffiHandle: UInt64,
            transaction: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeOnInvoiceEventCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.failure(
                     transaction: try FfiConverterOptionTypeTransaction.lift(transaction)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeOnInvoiceEventCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface OnInvoiceEventCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitOnInvoiceEventCallback() {
    uniffi_lni_fn_init_callback_vtable_oninvoiceeventcallback(UniffiCallbackInterfaceOnInvoiceEventCallback.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnInvoiceEventCallback: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<OnInvoiceEventCallback>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OnInvoiceEventCallback

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OnInvoiceEventCallback {
        return OnInvoiceEventCallbackImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OnInvoiceEventCallback) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnInvoiceEventCallback {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OnInvoiceEventCallback, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnInvoiceEventCallback_lift(_ pointer: UnsafeMutableRawPointer) throws -> OnInvoiceEventCallback {
    return try FfiConverterTypeOnInvoiceEventCallback.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnInvoiceEventCallback_lower(_ value: OnInvoiceEventCallback) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOnInvoiceEventCallback.lower(value)
}






public protocol PhoenixdNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class PhoenixdNode: PhoenixdNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_phoenixdnode(self.pointer, $0) }
    }
public convenience init(config: PhoenixdConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_phoenixdnode_new(
        FfiConverterTypePhoenixdConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_phoenixdnode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_phoenixdnode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePhoenixdNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PhoenixdNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PhoenixdNode {
        return PhoenixdNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PhoenixdNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PhoenixdNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PhoenixdNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoenixdNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> PhoenixdNode {
    return try FfiConverterTypePhoenixdNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoenixdNode_lower(_ value: PhoenixdNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypePhoenixdNode.lower(value)
}






public protocol SpeedNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class SpeedNode: SpeedNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_speednode(self.pointer, $0) }
    }
public convenience init(config: SpeedConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_speednode_new(
        FfiConverterTypeSpeedConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_speednode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_speednode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpeedNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SpeedNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SpeedNode {
        return SpeedNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SpeedNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpeedNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SpeedNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpeedNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> SpeedNode {
    return try FfiConverterTypeSpeedNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpeedNode_lower(_ value: SpeedNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSpeedNode.lower(value)
}






public protocol StrikeNodeProtocol: AnyObject, Sendable {
    
    func createInvoice(params: CreateInvoiceParams) async throws  -> Transaction
    
    func createOffer(params: CreateOfferParams) async throws  -> Offer
    
    func decode(str: String) async throws  -> String
    
    func getInfo() async throws  -> NodeInfo
    
    func getOffer(search: String?) async throws  -> Offer
    
    func listOffers(search: String?) async throws  -> [Offer]
    
    func listTransactions(params: ListTransactionsParams) async throws  -> [Transaction]
    
    func lookupInvoice(params: LookupInvoiceParams) async throws  -> Transaction
    
    func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback) async 
    
    func payInvoice(params: PayInvoiceParams) async throws  -> PayInvoiceResponse
    
    func payOffer(offer: String, amountMsats: Int64, payerNote: String?) async throws  -> PayInvoiceResponse
    
}
open class StrikeNode: StrikeNodeProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_lni_fn_clone_strikenode(self.pointer, $0) }
    }
public convenience init(config: StrikeConfig) {
    let pointer =
        try! rustCall() {
    uniffi_lni_fn_constructor_strikenode_new(
        FfiConverterTypeStrikeConfig_lower(config),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_lni_fn_free_strikenode(pointer, $0) }
    }

    

    
open func createInvoice(params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_create_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func createOffer(params: CreateOfferParams)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_create_offer(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCreateOfferParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func decode(str: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_decode(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(str)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getInfo()async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_get_info(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func getOffer(search: String?)async throws  -> Offer  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_get_offer(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeOffer_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listOffers(search: String?)async throws  -> [Offer]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_list_offers(
                    self.uniffiClonePointer(),
                    FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeOffer.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func listTransactions(params: ListTransactionsParams)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_list_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeListTransactionsParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func lookupInvoice(params: LookupInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_lookup_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypeLookupInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func onInvoiceEvents(params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_on_invoice_events(
                    self.uniffiClonePointer(),
                    FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func payInvoice(params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_pay_invoice(
                    self.uniffiClonePointer(),
                    FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    
open func payOffer(offer: String, amountMsats: Int64, payerNote: String?)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_method_strikenode_pay_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(offer),FfiConverterInt64.lower(amountMsats),FfiConverterOptionString.lower(payerNote)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStrikeNode: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StrikeNode

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StrikeNode {
        return StrikeNode(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StrikeNode) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StrikeNode {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StrikeNode, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStrikeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> StrikeNode {
    return try FfiConverterTypeStrikeNode.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStrikeNode_lower(_ value: StrikeNode) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStrikeNode.lower(value)
}




public struct BalancesResponse {
    public var onchain: OnchainBalanceResponse
    public var lightning: LightningBalanceResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(onchain: OnchainBalanceResponse, lightning: LightningBalanceResponse) {
        self.onchain = onchain
        self.lightning = lightning
    }
}

#if compiler(>=6)
extension BalancesResponse: Sendable {}
#endif


extension BalancesResponse: Equatable, Hashable {
    public static func ==(lhs: BalancesResponse, rhs: BalancesResponse) -> Bool {
        if lhs.onchain != rhs.onchain {
            return false
        }
        if lhs.lightning != rhs.lightning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(onchain)
        hasher.combine(lightning)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBalancesResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BalancesResponse {
        return
            try BalancesResponse(
                onchain: FfiConverterTypeOnchainBalanceResponse.read(from: &buf), 
                lightning: FfiConverterTypeLightningBalanceResponse.read(from: &buf)
        )
    }

    public static func write(_ value: BalancesResponse, into buf: inout [UInt8]) {
        FfiConverterTypeOnchainBalanceResponse.write(value.onchain, into: &buf)
        FfiConverterTypeLightningBalanceResponse.write(value.lightning, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalancesResponse_lift(_ buf: RustBuffer) throws -> BalancesResponse {
    return try FfiConverterTypeBalancesResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBalancesResponse_lower(_ value: BalancesResponse) -> RustBuffer {
    return FfiConverterTypeBalancesResponse.lower(value)
}


public struct BlinkConfig {
    public var baseUrl: String?
    public var apiKey: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseUrl: String? = "https://api.blink.sv/graphql", apiKey: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.baseUrl = baseUrl
        self.apiKey = apiKey
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension BlinkConfig: Sendable {}
#endif


extension BlinkConfig: Equatable, Hashable {
    public static func ==(lhs: BlinkConfig, rhs: BlinkConfig) -> Bool {
        if lhs.baseUrl != rhs.baseUrl {
            return false
        }
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseUrl)
        hasher.combine(apiKey)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlinkConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlinkConfig {
        return
            try BlinkConfig(
                baseUrl: FfiConverterOptionString.read(from: &buf), 
                apiKey: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlinkConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.baseUrl, into: &buf)
        FfiConverterString.write(value.apiKey, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlinkConfig_lift(_ buf: RustBuffer) throws -> BlinkConfig {
    return try FfiConverterTypeBlinkConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlinkConfig_lower(_ value: BlinkConfig) -> RustBuffer {
    return FfiConverterTypeBlinkConfig.lower(value)
}


public struct Channel {
    public var localBalance: Int64
    public var localSpendableBalance: Int64
    public var remoteBalance: Int64
    public var id: String
    public var remotePubkey: String
    public var fundingTxId: String
    public var fundingTxVout: Int64
    public var active: Bool
    public var `public`: Bool
    public var internalChannel: String
    public var confirmations: Int64
    public var confirmationsRequired: Int64
    public var forwardingFeeBaseMsat: Int64
    public var unspendablePunishmentReserve: Int64
    public var counterpartyUnspendablePunishmentReserve: Int64
    public var error: String
    public var isOutbound: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(localBalance: Int64, localSpendableBalance: Int64, remoteBalance: Int64, id: String, remotePubkey: String, fundingTxId: String, fundingTxVout: Int64, active: Bool, `public`: Bool, internalChannel: String, confirmations: Int64, confirmationsRequired: Int64, forwardingFeeBaseMsat: Int64, unspendablePunishmentReserve: Int64, counterpartyUnspendablePunishmentReserve: Int64, error: String, isOutbound: Bool) {
        self.localBalance = localBalance
        self.localSpendableBalance = localSpendableBalance
        self.remoteBalance = remoteBalance
        self.id = id
        self.remotePubkey = remotePubkey
        self.fundingTxId = fundingTxId
        self.fundingTxVout = fundingTxVout
        self.active = active
        self.`public` = `public`
        self.internalChannel = internalChannel
        self.confirmations = confirmations
        self.confirmationsRequired = confirmationsRequired
        self.forwardingFeeBaseMsat = forwardingFeeBaseMsat
        self.unspendablePunishmentReserve = unspendablePunishmentReserve
        self.counterpartyUnspendablePunishmentReserve = counterpartyUnspendablePunishmentReserve
        self.error = error
        self.isOutbound = isOutbound
    }
}

#if compiler(>=6)
extension Channel: Sendable {}
#endif


extension Channel: Equatable, Hashable {
    public static func ==(lhs: Channel, rhs: Channel) -> Bool {
        if lhs.localBalance != rhs.localBalance {
            return false
        }
        if lhs.localSpendableBalance != rhs.localSpendableBalance {
            return false
        }
        if lhs.remoteBalance != rhs.remoteBalance {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.remotePubkey != rhs.remotePubkey {
            return false
        }
        if lhs.fundingTxId != rhs.fundingTxId {
            return false
        }
        if lhs.fundingTxVout != rhs.fundingTxVout {
            return false
        }
        if lhs.active != rhs.active {
            return false
        }
        if lhs.`public` != rhs.`public` {
            return false
        }
        if lhs.internalChannel != rhs.internalChannel {
            return false
        }
        if lhs.confirmations != rhs.confirmations {
            return false
        }
        if lhs.confirmationsRequired != rhs.confirmationsRequired {
            return false
        }
        if lhs.forwardingFeeBaseMsat != rhs.forwardingFeeBaseMsat {
            return false
        }
        if lhs.unspendablePunishmentReserve != rhs.unspendablePunishmentReserve {
            return false
        }
        if lhs.counterpartyUnspendablePunishmentReserve != rhs.counterpartyUnspendablePunishmentReserve {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.isOutbound != rhs.isOutbound {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(localBalance)
        hasher.combine(localSpendableBalance)
        hasher.combine(remoteBalance)
        hasher.combine(id)
        hasher.combine(remotePubkey)
        hasher.combine(fundingTxId)
        hasher.combine(fundingTxVout)
        hasher.combine(active)
        hasher.combine(`public`)
        hasher.combine(internalChannel)
        hasher.combine(confirmations)
        hasher.combine(confirmationsRequired)
        hasher.combine(forwardingFeeBaseMsat)
        hasher.combine(unspendablePunishmentReserve)
        hasher.combine(counterpartyUnspendablePunishmentReserve)
        hasher.combine(error)
        hasher.combine(isOutbound)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChannel: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Channel {
        return
            try Channel(
                localBalance: FfiConverterInt64.read(from: &buf), 
                localSpendableBalance: FfiConverterInt64.read(from: &buf), 
                remoteBalance: FfiConverterInt64.read(from: &buf), 
                id: FfiConverterString.read(from: &buf), 
                remotePubkey: FfiConverterString.read(from: &buf), 
                fundingTxId: FfiConverterString.read(from: &buf), 
                fundingTxVout: FfiConverterInt64.read(from: &buf), 
                active: FfiConverterBool.read(from: &buf), 
                public: FfiConverterBool.read(from: &buf), 
                internalChannel: FfiConverterString.read(from: &buf), 
                confirmations: FfiConverterInt64.read(from: &buf), 
                confirmationsRequired: FfiConverterInt64.read(from: &buf), 
                forwardingFeeBaseMsat: FfiConverterInt64.read(from: &buf), 
                unspendablePunishmentReserve: FfiConverterInt64.read(from: &buf), 
                counterpartyUnspendablePunishmentReserve: FfiConverterInt64.read(from: &buf), 
                error: FfiConverterString.read(from: &buf), 
                isOutbound: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Channel, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.localBalance, into: &buf)
        FfiConverterInt64.write(value.localSpendableBalance, into: &buf)
        FfiConverterInt64.write(value.remoteBalance, into: &buf)
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.remotePubkey, into: &buf)
        FfiConverterString.write(value.fundingTxId, into: &buf)
        FfiConverterInt64.write(value.fundingTxVout, into: &buf)
        FfiConverterBool.write(value.active, into: &buf)
        FfiConverterBool.write(value.`public`, into: &buf)
        FfiConverterString.write(value.internalChannel, into: &buf)
        FfiConverterInt64.write(value.confirmations, into: &buf)
        FfiConverterInt64.write(value.confirmationsRequired, into: &buf)
        FfiConverterInt64.write(value.forwardingFeeBaseMsat, into: &buf)
        FfiConverterInt64.write(value.unspendablePunishmentReserve, into: &buf)
        FfiConverterInt64.write(value.counterpartyUnspendablePunishmentReserve, into: &buf)
        FfiConverterString.write(value.error, into: &buf)
        FfiConverterBool.write(value.isOutbound, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannel_lift(_ buf: RustBuffer) throws -> Channel {
    return try FfiConverterTypeChannel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChannel_lower(_ value: Channel) -> RustBuffer {
    return FfiConverterTypeChannel.lower(value)
}


public struct ClnConfig {
    public var url: String
    public var rune: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, rune: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.url = url
        self.rune = rune
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension ClnConfig: Sendable {}
#endif


extension ClnConfig: Equatable, Hashable {
    public static func ==(lhs: ClnConfig, rhs: ClnConfig) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.rune != rhs.rune {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(rune)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClnConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClnConfig {
        return
            try ClnConfig(
                url: FfiConverterString.read(from: &buf), 
                rune: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ClnConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.rune, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClnConfig_lift(_ buf: RustBuffer) throws -> ClnConfig {
    return try FfiConverterTypeClnConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClnConfig_lower(_ value: ClnConfig) -> RustBuffer {
    return FfiConverterTypeClnConfig.lower(value)
}


public struct CloseChannelRequest {
    public var channelId: String
    public var nodeId: String
    public var force: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelId: String, nodeId: String, force: Bool) {
        self.channelId = channelId
        self.nodeId = nodeId
        self.force = force
    }
}

#if compiler(>=6)
extension CloseChannelRequest: Sendable {}
#endif


extension CloseChannelRequest: Equatable, Hashable {
    public static func ==(lhs: CloseChannelRequest, rhs: CloseChannelRequest) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.force != rhs.force {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(nodeId)
        hasher.combine(force)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCloseChannelRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CloseChannelRequest {
        return
            try CloseChannelRequest(
                channelId: FfiConverterString.read(from: &buf), 
                nodeId: FfiConverterString.read(from: &buf), 
                force: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CloseChannelRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.channelId, into: &buf)
        FfiConverterString.write(value.nodeId, into: &buf)
        FfiConverterBool.write(value.force, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloseChannelRequest_lift(_ buf: RustBuffer) throws -> CloseChannelRequest {
    return try FfiConverterTypeCloseChannelRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloseChannelRequest_lower(_ value: CloseChannelRequest) -> RustBuffer {
    return FfiConverterTypeCloseChannelRequest.lower(value)
}


public struct CloseChannelResponse {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}

#if compiler(>=6)
extension CloseChannelResponse: Sendable {}
#endif


extension CloseChannelResponse: Equatable, Hashable {
    public static func ==(lhs: CloseChannelResponse, rhs: CloseChannelResponse) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCloseChannelResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CloseChannelResponse {
        return
            CloseChannelResponse()
    }

    public static func write(_ value: CloseChannelResponse, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloseChannelResponse_lift(_ buf: RustBuffer) throws -> CloseChannelResponse {
    return try FfiConverterTypeCloseChannelResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCloseChannelResponse_lower(_ value: CloseChannelResponse) -> RustBuffer {
    return FfiConverterTypeCloseChannelResponse.lower(value)
}


public struct ConnectPeerRequest {
    public var pubkey: String
    public var address: String
    public var port: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, address: String, port: Int64) {
        self.pubkey = pubkey
        self.address = address
        self.port = port
    }
}

#if compiler(>=6)
extension ConnectPeerRequest: Sendable {}
#endif


extension ConnectPeerRequest: Equatable, Hashable {
    public static func ==(lhs: ConnectPeerRequest, rhs: ConnectPeerRequest) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.port != rhs.port {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(address)
        hasher.combine(port)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectPeerRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectPeerRequest {
        return
            try ConnectPeerRequest(
                pubkey: FfiConverterString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf), 
                port: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ConnectPeerRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterInt64.write(value.port, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectPeerRequest_lift(_ buf: RustBuffer) throws -> ConnectPeerRequest {
    return try FfiConverterTypeConnectPeerRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectPeerRequest_lower(_ value: ConnectPeerRequest) -> RustBuffer {
    return FfiConverterTypeConnectPeerRequest.lower(value)
}


public struct CreateInvoiceParams {
    /**
     * Defaults to Bolt11 if not specified
     */
    public var invoiceType: InvoiceType?
    public var amountMsats: Int64?
    public var offer: String?
    public var description: String?
    public var descriptionHash: String?
    public var expiry: Int64?
    public var rPreimage: String?
    public var isBlinded: Bool?
    public var isKeysend: Bool?
    public var isAmp: Bool?
    public var isPrivate: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Defaults to Bolt11 if not specified
         */invoiceType: InvoiceType? = nil, amountMsats: Int64? = nil, offer: String? = nil, description: String? = nil, descriptionHash: String? = nil, expiry: Int64? = nil, rPreimage: String? = nil, isBlinded: Bool? = false, isKeysend: Bool? = false, isAmp: Bool? = false, isPrivate: Bool? = false) {
        self.invoiceType = invoiceType
        self.amountMsats = amountMsats
        self.offer = offer
        self.description = description
        self.descriptionHash = descriptionHash
        self.expiry = expiry
        self.rPreimage = rPreimage
        self.isBlinded = isBlinded
        self.isKeysend = isKeysend
        self.isAmp = isAmp
        self.isPrivate = isPrivate
    }
}

#if compiler(>=6)
extension CreateInvoiceParams: Sendable {}
#endif


extension CreateInvoiceParams: Equatable, Hashable {
    public static func ==(lhs: CreateInvoiceParams, rhs: CreateInvoiceParams) -> Bool {
        if lhs.invoiceType != rhs.invoiceType {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        if lhs.offer != rhs.offer {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        if lhs.rPreimage != rhs.rPreimage {
            return false
        }
        if lhs.isBlinded != rhs.isBlinded {
            return false
        }
        if lhs.isKeysend != rhs.isKeysend {
            return false
        }
        if lhs.isAmp != rhs.isAmp {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoiceType)
        hasher.combine(amountMsats)
        hasher.combine(offer)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(expiry)
        hasher.combine(rPreimage)
        hasher.combine(isBlinded)
        hasher.combine(isKeysend)
        hasher.combine(isAmp)
        hasher.combine(isPrivate)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateInvoiceParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateInvoiceParams {
        return
            try CreateInvoiceParams(
                invoiceType: FfiConverterOptionTypeInvoiceType.read(from: &buf), 
                amountMsats: FfiConverterOptionInt64.read(from: &buf), 
                offer: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionInt64.read(from: &buf), 
                rPreimage: FfiConverterOptionString.read(from: &buf), 
                isBlinded: FfiConverterOptionBool.read(from: &buf), 
                isKeysend: FfiConverterOptionBool.read(from: &buf), 
                isAmp: FfiConverterOptionBool.read(from: &buf), 
                isPrivate: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: CreateInvoiceParams, into buf: inout [UInt8]) {
        FfiConverterOptionTypeInvoiceType.write(value.invoiceType, into: &buf)
        FfiConverterOptionInt64.write(value.amountMsats, into: &buf)
        FfiConverterOptionString.write(value.offer, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionInt64.write(value.expiry, into: &buf)
        FfiConverterOptionString.write(value.rPreimage, into: &buf)
        FfiConverterOptionBool.write(value.isBlinded, into: &buf)
        FfiConverterOptionBool.write(value.isKeysend, into: &buf)
        FfiConverterOptionBool.write(value.isAmp, into: &buf)
        FfiConverterOptionBool.write(value.isPrivate, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateInvoiceParams_lift(_ buf: RustBuffer) throws -> CreateInvoiceParams {
    return try FfiConverterTypeCreateInvoiceParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateInvoiceParams_lower(_ value: CreateInvoiceParams) -> RustBuffer {
    return FfiConverterTypeCreateInvoiceParams.lower(value)
}


public struct CreateOfferParams {
    public var description: String?
    public var amountMsats: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(description: String?, amountMsats: Int64?) {
        self.description = description
        self.amountMsats = amountMsats
    }
}

#if compiler(>=6)
extension CreateOfferParams: Sendable {}
#endif


extension CreateOfferParams: Equatable, Hashable {
    public static func ==(lhs: CreateOfferParams, rhs: CreateOfferParams) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(amountMsats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateOfferParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateOfferParams {
        return
            try CreateOfferParams(
                description: FfiConverterOptionString.read(from: &buf), 
                amountMsats: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: CreateOfferParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionInt64.write(value.amountMsats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateOfferParams_lift(_ buf: RustBuffer) throws -> CreateOfferParams {
    return try FfiConverterTypeCreateOfferParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateOfferParams_lower(_ value: CreateOfferParams) -> RustBuffer {
    return FfiConverterTypeCreateOfferParams.lower(value)
}


public struct LightningBalanceResponse {
    public var totalSpendable: Int64
    public var totalReceivable: Int64
    public var nextMaxSpendable: Int64
    public var nextMaxReceivable: Int64
    public var nextMaxSpendableMpp: Int64
    public var nextMaxReceivableMpp: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalSpendable: Int64, totalReceivable: Int64, nextMaxSpendable: Int64, nextMaxReceivable: Int64, nextMaxSpendableMpp: Int64, nextMaxReceivableMpp: Int64) {
        self.totalSpendable = totalSpendable
        self.totalReceivable = totalReceivable
        self.nextMaxSpendable = nextMaxSpendable
        self.nextMaxReceivable = nextMaxReceivable
        self.nextMaxSpendableMpp = nextMaxSpendableMpp
        self.nextMaxReceivableMpp = nextMaxReceivableMpp
    }
}

#if compiler(>=6)
extension LightningBalanceResponse: Sendable {}
#endif


extension LightningBalanceResponse: Equatable, Hashable {
    public static func ==(lhs: LightningBalanceResponse, rhs: LightningBalanceResponse) -> Bool {
        if lhs.totalSpendable != rhs.totalSpendable {
            return false
        }
        if lhs.totalReceivable != rhs.totalReceivable {
            return false
        }
        if lhs.nextMaxSpendable != rhs.nextMaxSpendable {
            return false
        }
        if lhs.nextMaxReceivable != rhs.nextMaxReceivable {
            return false
        }
        if lhs.nextMaxSpendableMpp != rhs.nextMaxSpendableMpp {
            return false
        }
        if lhs.nextMaxReceivableMpp != rhs.nextMaxReceivableMpp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalSpendable)
        hasher.combine(totalReceivable)
        hasher.combine(nextMaxSpendable)
        hasher.combine(nextMaxReceivable)
        hasher.combine(nextMaxSpendableMpp)
        hasher.combine(nextMaxReceivableMpp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLightningBalanceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LightningBalanceResponse {
        return
            try LightningBalanceResponse(
                totalSpendable: FfiConverterInt64.read(from: &buf), 
                totalReceivable: FfiConverterInt64.read(from: &buf), 
                nextMaxSpendable: FfiConverterInt64.read(from: &buf), 
                nextMaxReceivable: FfiConverterInt64.read(from: &buf), 
                nextMaxSpendableMpp: FfiConverterInt64.read(from: &buf), 
                nextMaxReceivableMpp: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LightningBalanceResponse, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.totalSpendable, into: &buf)
        FfiConverterInt64.write(value.totalReceivable, into: &buf)
        FfiConverterInt64.write(value.nextMaxSpendable, into: &buf)
        FfiConverterInt64.write(value.nextMaxReceivable, into: &buf)
        FfiConverterInt64.write(value.nextMaxSpendableMpp, into: &buf)
        FfiConverterInt64.write(value.nextMaxReceivableMpp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningBalanceResponse_lift(_ buf: RustBuffer) throws -> LightningBalanceResponse {
    return try FfiConverterTypeLightningBalanceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLightningBalanceResponse_lower(_ value: LightningBalanceResponse) -> RustBuffer {
    return FfiConverterTypeLightningBalanceResponse.lower(value)
}


public struct ListTransactionsParams {
    public var from: Int64
    public var limit: Int64
    public var paymentHash: String?
    public var search: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(from: Int64, limit: Int64, paymentHash: String?, search: String?) {
        self.from = from
        self.limit = limit
        self.paymentHash = paymentHash
        self.search = search
    }
}

#if compiler(>=6)
extension ListTransactionsParams: Sendable {}
#endif


extension ListTransactionsParams: Equatable, Hashable {
    public static func ==(lhs: ListTransactionsParams, rhs: ListTransactionsParams) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.search != rhs.search {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(limit)
        hasher.combine(paymentHash)
        hasher.combine(search)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeListTransactionsParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListTransactionsParams {
        return
            try ListTransactionsParams(
                from: FfiConverterInt64.read(from: &buf), 
                limit: FfiConverterInt64.read(from: &buf), 
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ListTransactionsParams, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.from, into: &buf)
        FfiConverterInt64.write(value.limit, into: &buf)
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListTransactionsParams_lift(_ buf: RustBuffer) throws -> ListTransactionsParams {
    return try FfiConverterTypeListTransactionsParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeListTransactionsParams_lower(_ value: ListTransactionsParams) -> RustBuffer {
    return FfiConverterTypeListTransactionsParams.lower(value)
}


public struct LndConfig {
    public var url: String
    public var macaroon: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, macaroon: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.url = url
        self.macaroon = macaroon
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension LndConfig: Sendable {}
#endif


extension LndConfig: Equatable, Hashable {
    public static func ==(lhs: LndConfig, rhs: LndConfig) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.macaroon != rhs.macaroon {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(macaroon)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLndConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LndConfig {
        return
            try LndConfig(
                url: FfiConverterString.read(from: &buf), 
                macaroon: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LndConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.macaroon, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLndConfig_lift(_ buf: RustBuffer) throws -> LndConfig {
    return try FfiConverterTypeLndConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLndConfig_lower(_ value: LndConfig) -> RustBuffer {
    return FfiConverterTypeLndConfig.lower(value)
}


public struct LookupInvoiceParams {
    public var paymentHash: String?
    public var search: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String?, search: String?) {
        self.paymentHash = paymentHash
        self.search = search
    }
}

#if compiler(>=6)
extension LookupInvoiceParams: Sendable {}
#endif


extension LookupInvoiceParams: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceParams, rhs: LookupInvoiceParams) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.search != rhs.search {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(search)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLookupInvoiceParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceParams {
        return
            try LookupInvoiceParams(
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceParams_lift(_ buf: RustBuffer) throws -> LookupInvoiceParams {
    return try FfiConverterTypeLookupInvoiceParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLookupInvoiceParams_lower(_ value: LookupInvoiceParams) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceParams.lower(value)
}


public struct NodeConnectionInfo {
    public var pubkey: String
    public var address: String
    public var port: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, address: String, port: Int64) {
        self.pubkey = pubkey
        self.address = address
        self.port = port
    }
}

#if compiler(>=6)
extension NodeConnectionInfo: Sendable {}
#endif


extension NodeConnectionInfo: Equatable, Hashable {
    public static func ==(lhs: NodeConnectionInfo, rhs: NodeConnectionInfo) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.port != rhs.port {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(address)
        hasher.combine(port)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeConnectionInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeConnectionInfo {
        return
            try NodeConnectionInfo(
                pubkey: FfiConverterString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf), 
                port: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeConnectionInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterInt64.write(value.port, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeConnectionInfo_lift(_ buf: RustBuffer) throws -> NodeConnectionInfo {
    return try FfiConverterTypeNodeConnectionInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeConnectionInfo_lower(_ value: NodeConnectionInfo) -> RustBuffer {
    return FfiConverterTypeNodeConnectionInfo.lower(value)
}


public struct NodeInfo {
    public var alias: String
    public var color: String
    public var pubkey: String
    public var network: String
    public var blockHeight: Int64
    public var blockHash: String
    public var sendBalanceMsat: Int64
    public var receiveBalanceMsat: Int64
    public var feeCreditBalanceMsat: Int64
    public var unsettledSendBalanceMsat: Int64
    public var unsettledReceiveBalanceMsat: Int64
    public var pendingOpenSendBalance: Int64
    public var pendingOpenReceiveBalance: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(alias: String, color: String, pubkey: String, network: String, blockHeight: Int64, blockHash: String, sendBalanceMsat: Int64, receiveBalanceMsat: Int64, feeCreditBalanceMsat: Int64, unsettledSendBalanceMsat: Int64, unsettledReceiveBalanceMsat: Int64, pendingOpenSendBalance: Int64, pendingOpenReceiveBalance: Int64) {
        self.alias = alias
        self.color = color
        self.pubkey = pubkey
        self.network = network
        self.blockHeight = blockHeight
        self.blockHash = blockHash
        self.sendBalanceMsat = sendBalanceMsat
        self.receiveBalanceMsat = receiveBalanceMsat
        self.feeCreditBalanceMsat = feeCreditBalanceMsat
        self.unsettledSendBalanceMsat = unsettledSendBalanceMsat
        self.unsettledReceiveBalanceMsat = unsettledReceiveBalanceMsat
        self.pendingOpenSendBalance = pendingOpenSendBalance
        self.pendingOpenReceiveBalance = pendingOpenReceiveBalance
    }
}

#if compiler(>=6)
extension NodeInfo: Sendable {}
#endif


extension NodeInfo: Equatable, Hashable {
    public static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
        if lhs.alias != rhs.alias {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.blockHeight != rhs.blockHeight {
            return false
        }
        if lhs.blockHash != rhs.blockHash {
            return false
        }
        if lhs.sendBalanceMsat != rhs.sendBalanceMsat {
            return false
        }
        if lhs.receiveBalanceMsat != rhs.receiveBalanceMsat {
            return false
        }
        if lhs.feeCreditBalanceMsat != rhs.feeCreditBalanceMsat {
            return false
        }
        if lhs.unsettledSendBalanceMsat != rhs.unsettledSendBalanceMsat {
            return false
        }
        if lhs.unsettledReceiveBalanceMsat != rhs.unsettledReceiveBalanceMsat {
            return false
        }
        if lhs.pendingOpenSendBalance != rhs.pendingOpenSendBalance {
            return false
        }
        if lhs.pendingOpenReceiveBalance != rhs.pendingOpenReceiveBalance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(alias)
        hasher.combine(color)
        hasher.combine(pubkey)
        hasher.combine(network)
        hasher.combine(blockHeight)
        hasher.combine(blockHash)
        hasher.combine(sendBalanceMsat)
        hasher.combine(receiveBalanceMsat)
        hasher.combine(feeCreditBalanceMsat)
        hasher.combine(unsettledSendBalanceMsat)
        hasher.combine(unsettledReceiveBalanceMsat)
        hasher.combine(pendingOpenSendBalance)
        hasher.combine(pendingOpenReceiveBalance)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeInfo {
        return
            try NodeInfo(
                alias: FfiConverterString.read(from: &buf), 
                color: FfiConverterString.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                network: FfiConverterString.read(from: &buf), 
                blockHeight: FfiConverterInt64.read(from: &buf), 
                blockHash: FfiConverterString.read(from: &buf), 
                sendBalanceMsat: FfiConverterInt64.read(from: &buf), 
                receiveBalanceMsat: FfiConverterInt64.read(from: &buf), 
                feeCreditBalanceMsat: FfiConverterInt64.read(from: &buf), 
                unsettledSendBalanceMsat: FfiConverterInt64.read(from: &buf), 
                unsettledReceiveBalanceMsat: FfiConverterInt64.read(from: &buf), 
                pendingOpenSendBalance: FfiConverterInt64.read(from: &buf), 
                pendingOpenReceiveBalance: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.alias, into: &buf)
        FfiConverterString.write(value.color, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterString.write(value.network, into: &buf)
        FfiConverterInt64.write(value.blockHeight, into: &buf)
        FfiConverterString.write(value.blockHash, into: &buf)
        FfiConverterInt64.write(value.sendBalanceMsat, into: &buf)
        FfiConverterInt64.write(value.receiveBalanceMsat, into: &buf)
        FfiConverterInt64.write(value.feeCreditBalanceMsat, into: &buf)
        FfiConverterInt64.write(value.unsettledSendBalanceMsat, into: &buf)
        FfiConverterInt64.write(value.unsettledReceiveBalanceMsat, into: &buf)
        FfiConverterInt64.write(value.pendingOpenSendBalance, into: &buf)
        FfiConverterInt64.write(value.pendingOpenReceiveBalance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lift(_ buf: RustBuffer) throws -> NodeInfo {
    return try FfiConverterTypeNodeInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeInfo_lower(_ value: NodeInfo) -> RustBuffer {
    return FfiConverterTypeNodeInfo.lower(value)
}


public struct NodeStatus {
    public var isReady: Bool
    public var internalNodeStatus: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isReady: Bool, internalNodeStatus: String) {
        self.isReady = isReady
        self.internalNodeStatus = internalNodeStatus
    }
}

#if compiler(>=6)
extension NodeStatus: Sendable {}
#endif


extension NodeStatus: Equatable, Hashable {
    public static func ==(lhs: NodeStatus, rhs: NodeStatus) -> Bool {
        if lhs.isReady != rhs.isReady {
            return false
        }
        if lhs.internalNodeStatus != rhs.internalNodeStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isReady)
        hasher.combine(internalNodeStatus)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeStatus {
        return
            try NodeStatus(
                isReady: FfiConverterBool.read(from: &buf), 
                internalNodeStatus: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isReady, into: &buf)
        FfiConverterString.write(value.internalNodeStatus, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeStatus_lift(_ buf: RustBuffer) throws -> NodeStatus {
    return try FfiConverterTypeNodeStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeStatus_lower(_ value: NodeStatus) -> RustBuffer {
    return FfiConverterTypeNodeStatus.lower(value)
}


public struct NwcConfig {
    public var nwcUri: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nwcUri: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.nwcUri = nwcUri
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension NwcConfig: Sendable {}
#endif


extension NwcConfig: Equatable, Hashable {
    public static func ==(lhs: NwcConfig, rhs: NwcConfig) -> Bool {
        if lhs.nwcUri != rhs.nwcUri {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nwcUri)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNwcConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NwcConfig {
        return
            try NwcConfig(
                nwcUri: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NwcConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nwcUri, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNwcConfig_lift(_ buf: RustBuffer) throws -> NwcConfig {
    return try FfiConverterTypeNwcConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNwcConfig_lower(_ value: NwcConfig) -> RustBuffer {
    return FfiConverterTypeNwcConfig.lower(value)
}


public struct Offer {
    public var offerId: String
    public var bolt12: String
    public var label: String?
    public var active: Bool?
    public var singleUse: Bool?
    public var used: Bool?
    public var amountMsats: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(offerId: String, bolt12: String, label: String?, active: Bool?, singleUse: Bool?, used: Bool?, amountMsats: Int64?) {
        self.offerId = offerId
        self.bolt12 = bolt12
        self.label = label
        self.active = active
        self.singleUse = singleUse
        self.used = used
        self.amountMsats = amountMsats
    }
}

#if compiler(>=6)
extension Offer: Sendable {}
#endif


extension Offer: Equatable, Hashable {
    public static func ==(lhs: Offer, rhs: Offer) -> Bool {
        if lhs.offerId != rhs.offerId {
            return false
        }
        if lhs.bolt12 != rhs.bolt12 {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.active != rhs.active {
            return false
        }
        if lhs.singleUse != rhs.singleUse {
            return false
        }
        if lhs.used != rhs.used {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(offerId)
        hasher.combine(bolt12)
        hasher.combine(label)
        hasher.combine(active)
        hasher.combine(singleUse)
        hasher.combine(used)
        hasher.combine(amountMsats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOffer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Offer {
        return
            try Offer(
                offerId: FfiConverterString.read(from: &buf), 
                bolt12: FfiConverterString.read(from: &buf), 
                label: FfiConverterOptionString.read(from: &buf), 
                active: FfiConverterOptionBool.read(from: &buf), 
                singleUse: FfiConverterOptionBool.read(from: &buf), 
                used: FfiConverterOptionBool.read(from: &buf), 
                amountMsats: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Offer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.offerId, into: &buf)
        FfiConverterString.write(value.bolt12, into: &buf)
        FfiConverterOptionString.write(value.label, into: &buf)
        FfiConverterOptionBool.write(value.active, into: &buf)
        FfiConverterOptionBool.write(value.singleUse, into: &buf)
        FfiConverterOptionBool.write(value.used, into: &buf)
        FfiConverterOptionInt64.write(value.amountMsats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffer_lift(_ buf: RustBuffer) throws -> Offer {
    return try FfiConverterTypeOffer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffer_lower(_ value: Offer) -> RustBuffer {
    return FfiConverterTypeOffer.lower(value)
}


public struct OnInvoiceEventParams {
    public var paymentHash: String?
    public var search: String?
    public var pollingDelaySec: Int64
    public var maxPollingSec: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String?, search: String?, pollingDelaySec: Int64, maxPollingSec: Int64) {
        self.paymentHash = paymentHash
        self.search = search
        self.pollingDelaySec = pollingDelaySec
        self.maxPollingSec = maxPollingSec
    }
}

#if compiler(>=6)
extension OnInvoiceEventParams: Sendable {}
#endif


extension OnInvoiceEventParams: Equatable, Hashable {
    public static func ==(lhs: OnInvoiceEventParams, rhs: OnInvoiceEventParams) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.search != rhs.search {
            return false
        }
        if lhs.pollingDelaySec != rhs.pollingDelaySec {
            return false
        }
        if lhs.maxPollingSec != rhs.maxPollingSec {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(search)
        hasher.combine(pollingDelaySec)
        hasher.combine(maxPollingSec)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnInvoiceEventParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnInvoiceEventParams {
        return
            try OnInvoiceEventParams(
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                search: FfiConverterOptionString.read(from: &buf), 
                pollingDelaySec: FfiConverterInt64.read(from: &buf), 
                maxPollingSec: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: OnInvoiceEventParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.search, into: &buf)
        FfiConverterInt64.write(value.pollingDelaySec, into: &buf)
        FfiConverterInt64.write(value.maxPollingSec, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnInvoiceEventParams_lift(_ buf: RustBuffer) throws -> OnInvoiceEventParams {
    return try FfiConverterTypeOnInvoiceEventParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnInvoiceEventParams_lower(_ value: OnInvoiceEventParams) -> RustBuffer {
    return FfiConverterTypeOnInvoiceEventParams.lower(value)
}


public struct OnchainBalanceResponse {
    public var spendable: Int64
    public var total: Int64
    public var reserved: Int64
    public var pendingBalancesFromChannelClosures: Int64
    public var pendingBalancesDetails: [PendingBalanceDetails]
    public var internalBalances: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(spendable: Int64, total: Int64, reserved: Int64, pendingBalancesFromChannelClosures: Int64, pendingBalancesDetails: [PendingBalanceDetails], internalBalances: String) {
        self.spendable = spendable
        self.total = total
        self.reserved = reserved
        self.pendingBalancesFromChannelClosures = pendingBalancesFromChannelClosures
        self.pendingBalancesDetails = pendingBalancesDetails
        self.internalBalances = internalBalances
    }
}

#if compiler(>=6)
extension OnchainBalanceResponse: Sendable {}
#endif


extension OnchainBalanceResponse: Equatable, Hashable {
    public static func ==(lhs: OnchainBalanceResponse, rhs: OnchainBalanceResponse) -> Bool {
        if lhs.spendable != rhs.spendable {
            return false
        }
        if lhs.total != rhs.total {
            return false
        }
        if lhs.reserved != rhs.reserved {
            return false
        }
        if lhs.pendingBalancesFromChannelClosures != rhs.pendingBalancesFromChannelClosures {
            return false
        }
        if lhs.pendingBalancesDetails != rhs.pendingBalancesDetails {
            return false
        }
        if lhs.internalBalances != rhs.internalBalances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(spendable)
        hasher.combine(total)
        hasher.combine(reserved)
        hasher.combine(pendingBalancesFromChannelClosures)
        hasher.combine(pendingBalancesDetails)
        hasher.combine(internalBalances)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnchainBalanceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnchainBalanceResponse {
        return
            try OnchainBalanceResponse(
                spendable: FfiConverterInt64.read(from: &buf), 
                total: FfiConverterInt64.read(from: &buf), 
                reserved: FfiConverterInt64.read(from: &buf), 
                pendingBalancesFromChannelClosures: FfiConverterInt64.read(from: &buf), 
                pendingBalancesDetails: FfiConverterSequenceTypePendingBalanceDetails.read(from: &buf), 
                internalBalances: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OnchainBalanceResponse, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.spendable, into: &buf)
        FfiConverterInt64.write(value.total, into: &buf)
        FfiConverterInt64.write(value.reserved, into: &buf)
        FfiConverterInt64.write(value.pendingBalancesFromChannelClosures, into: &buf)
        FfiConverterSequenceTypePendingBalanceDetails.write(value.pendingBalancesDetails, into: &buf)
        FfiConverterString.write(value.internalBalances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainBalanceResponse_lift(_ buf: RustBuffer) throws -> OnchainBalanceResponse {
    return try FfiConverterTypeOnchainBalanceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnchainBalanceResponse_lower(_ value: OnchainBalanceResponse) -> RustBuffer {
    return FfiConverterTypeOnchainBalanceResponse.lower(value)
}


public struct OpenChannelRequest {
    public var pubkey: String
    public var amountMsats: Int64
    public var `public`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pubkey: String, amountMsats: Int64, `public`: Bool) {
        self.pubkey = pubkey
        self.amountMsats = amountMsats
        self.`public` = `public`
    }
}

#if compiler(>=6)
extension OpenChannelRequest: Sendable {}
#endif


extension OpenChannelRequest: Equatable, Hashable {
    public static func ==(lhs: OpenChannelRequest, rhs: OpenChannelRequest) -> Bool {
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        if lhs.`public` != rhs.`public` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pubkey)
        hasher.combine(amountMsats)
        hasher.combine(`public`)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenChannelRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenChannelRequest {
        return
            try OpenChannelRequest(
                pubkey: FfiConverterString.read(from: &buf), 
                amountMsats: FfiConverterInt64.read(from: &buf), 
                public: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: OpenChannelRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterInt64.write(value.amountMsats, into: &buf)
        FfiConverterBool.write(value.`public`, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenChannelRequest_lift(_ buf: RustBuffer) throws -> OpenChannelRequest {
    return try FfiConverterTypeOpenChannelRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenChannelRequest_lower(_ value: OpenChannelRequest) -> RustBuffer {
    return FfiConverterTypeOpenChannelRequest.lower(value)
}


public struct OpenChannelResponse {
    public var fundingTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fundingTxId: String) {
        self.fundingTxId = fundingTxId
    }
}

#if compiler(>=6)
extension OpenChannelResponse: Sendable {}
#endif


extension OpenChannelResponse: Equatable, Hashable {
    public static func ==(lhs: OpenChannelResponse, rhs: OpenChannelResponse) -> Bool {
        if lhs.fundingTxId != rhs.fundingTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fundingTxId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOpenChannelResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenChannelResponse {
        return
            try OpenChannelResponse(
                fundingTxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OpenChannelResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fundingTxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenChannelResponse_lift(_ buf: RustBuffer) throws -> OpenChannelResponse {
    return try FfiConverterTypeOpenChannelResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOpenChannelResponse_lower(_ value: OpenChannelResponse) -> RustBuffer {
    return FfiConverterTypeOpenChannelResponse.lower(value)
}


public struct PayInvoiceParams {
    public var invoice: String
    public var feeLimitMsat: Int64?
    public var feeLimitPercentage: Double?
    public var timeoutSeconds: Int64?
    public var amountMsats: Int64?
    public var maxParts: Int64?
    public var firstHopPubkey: String?
    public var lastHopPubkey: String?
    public var allowSelfPayment: Bool?
    public var isAmp: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(invoice: String, feeLimitMsat: Int64?, feeLimitPercentage: Double?, timeoutSeconds: Int64?, amountMsats: Int64?, maxParts: Int64?, firstHopPubkey: String?, lastHopPubkey: String?, allowSelfPayment: Bool?, isAmp: Bool?) {
        self.invoice = invoice
        self.feeLimitMsat = feeLimitMsat
        self.feeLimitPercentage = feeLimitPercentage
        self.timeoutSeconds = timeoutSeconds
        self.amountMsats = amountMsats
        self.maxParts = maxParts
        self.firstHopPubkey = firstHopPubkey
        self.lastHopPubkey = lastHopPubkey
        self.allowSelfPayment = allowSelfPayment
        self.isAmp = isAmp
    }
}

#if compiler(>=6)
extension PayInvoiceParams: Sendable {}
#endif


extension PayInvoiceParams: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceParams, rhs: PayInvoiceParams) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.feeLimitMsat != rhs.feeLimitMsat {
            return false
        }
        if lhs.feeLimitPercentage != rhs.feeLimitPercentage {
            return false
        }
        if lhs.timeoutSeconds != rhs.timeoutSeconds {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        if lhs.maxParts != rhs.maxParts {
            return false
        }
        if lhs.firstHopPubkey != rhs.firstHopPubkey {
            return false
        }
        if lhs.lastHopPubkey != rhs.lastHopPubkey {
            return false
        }
        if lhs.allowSelfPayment != rhs.allowSelfPayment {
            return false
        }
        if lhs.isAmp != rhs.isAmp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(feeLimitMsat)
        hasher.combine(feeLimitPercentage)
        hasher.combine(timeoutSeconds)
        hasher.combine(amountMsats)
        hasher.combine(maxParts)
        hasher.combine(firstHopPubkey)
        hasher.combine(lastHopPubkey)
        hasher.combine(allowSelfPayment)
        hasher.combine(isAmp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayInvoiceParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceParams {
        return
            try PayInvoiceParams(
                invoice: FfiConverterString.read(from: &buf), 
                feeLimitMsat: FfiConverterOptionInt64.read(from: &buf), 
                feeLimitPercentage: FfiConverterOptionDouble.read(from: &buf), 
                timeoutSeconds: FfiConverterOptionInt64.read(from: &buf), 
                amountMsats: FfiConverterOptionInt64.read(from: &buf), 
                maxParts: FfiConverterOptionInt64.read(from: &buf), 
                firstHopPubkey: FfiConverterOptionString.read(from: &buf), 
                lastHopPubkey: FfiConverterOptionString.read(from: &buf), 
                allowSelfPayment: FfiConverterOptionBool.read(from: &buf), 
                isAmp: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceParams, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionInt64.write(value.feeLimitMsat, into: &buf)
        FfiConverterOptionDouble.write(value.feeLimitPercentage, into: &buf)
        FfiConverterOptionInt64.write(value.timeoutSeconds, into: &buf)
        FfiConverterOptionInt64.write(value.amountMsats, into: &buf)
        FfiConverterOptionInt64.write(value.maxParts, into: &buf)
        FfiConverterOptionString.write(value.firstHopPubkey, into: &buf)
        FfiConverterOptionString.write(value.lastHopPubkey, into: &buf)
        FfiConverterOptionBool.write(value.allowSelfPayment, into: &buf)
        FfiConverterOptionBool.write(value.isAmp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceParams_lift(_ buf: RustBuffer) throws -> PayInvoiceParams {
    return try FfiConverterTypePayInvoiceParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceParams_lower(_ value: PayInvoiceParams) -> RustBuffer {
    return FfiConverterTypePayInvoiceParams.lower(value)
}


public struct PayInvoiceResponse {
    public var paymentHash: String
    public var preimage: String
    public var feeMsats: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(paymentHash: String, preimage: String, feeMsats: Int64) {
        self.paymentHash = paymentHash
        self.preimage = preimage
        self.feeMsats = feeMsats
    }
}

#if compiler(>=6)
extension PayInvoiceResponse: Sendable {}
#endif


extension PayInvoiceResponse: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceResponse, rhs: PayInvoiceResponse) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.feeMsats != rhs.feeMsats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(preimage)
        hasher.combine(feeMsats)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayInvoiceResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceResponse {
        return
            try PayInvoiceResponse(
                paymentHash: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterString.read(from: &buf), 
                feeMsats: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterInt64.write(value.feeMsats, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceResponse_lift(_ buf: RustBuffer) throws -> PayInvoiceResponse {
    return try FfiConverterTypePayInvoiceResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayInvoiceResponse_lower(_ value: PayInvoiceResponse) -> RustBuffer {
    return FfiConverterTypePayInvoiceResponse.lower(value)
}


public struct PayKeysendResponse {
    public var fee: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fee: Int64) {
        self.fee = fee
    }
}

#if compiler(>=6)
extension PayKeysendResponse: Sendable {}
#endif


extension PayKeysendResponse: Equatable, Hashable {
    public static func ==(lhs: PayKeysendResponse, rhs: PayKeysendResponse) -> Bool {
        if lhs.fee != rhs.fee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fee)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePayKeysendResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendResponse {
        return
            try PayKeysendResponse(
                fee: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendResponse, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.fee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendResponse_lift(_ buf: RustBuffer) throws -> PayKeysendResponse {
    return try FfiConverterTypePayKeysendResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePayKeysendResponse_lower(_ value: PayKeysendResponse) -> RustBuffer {
    return FfiConverterTypePayKeysendResponse.lower(value)
}


public struct PaymentFailedEventProperties {
    public var transaction: Transaction
    public var reason: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: Transaction, reason: String) {
        self.transaction = transaction
        self.reason = reason
    }
}

#if compiler(>=6)
extension PaymentFailedEventProperties: Sendable {}
#endif


extension PaymentFailedEventProperties: Equatable, Hashable {
    public static func ==(lhs: PaymentFailedEventProperties, rhs: PaymentFailedEventProperties) -> Bool {
        if lhs.transaction != rhs.transaction {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transaction)
        hasher.combine(reason)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePaymentFailedEventProperties: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailedEventProperties {
        return
            try PaymentFailedEventProperties(
                transaction: FfiConverterTypeTransaction.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentFailedEventProperties, into buf: inout [UInt8]) {
        FfiConverterTypeTransaction.write(value.transaction, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFailedEventProperties_lift(_ buf: RustBuffer) throws -> PaymentFailedEventProperties {
    return try FfiConverterTypePaymentFailedEventProperties.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePaymentFailedEventProperties_lower(_ value: PaymentFailedEventProperties) -> RustBuffer {
    return FfiConverterTypePaymentFailedEventProperties.lower(value)
}


public struct PeerDetails {
    public var nodeId: String
    public var address: String
    public var isPersisted: Bool
    public var isConnected: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nodeId: String, address: String, isPersisted: Bool, isConnected: Bool) {
        self.nodeId = nodeId
        self.address = address
        self.isPersisted = isPersisted
        self.isConnected = isConnected
    }
}

#if compiler(>=6)
extension PeerDetails: Sendable {}
#endif


extension PeerDetails: Equatable, Hashable {
    public static func ==(lhs: PeerDetails, rhs: PeerDetails) -> Bool {
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.isPersisted != rhs.isPersisted {
            return false
        }
        if lhs.isConnected != rhs.isConnected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nodeId)
        hasher.combine(address)
        hasher.combine(isPersisted)
        hasher.combine(isConnected)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePeerDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PeerDetails {
        return
            try PeerDetails(
                nodeId: FfiConverterString.read(from: &buf), 
                address: FfiConverterString.read(from: &buf), 
                isPersisted: FfiConverterBool.read(from: &buf), 
                isConnected: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: PeerDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.nodeId, into: &buf)
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterBool.write(value.isPersisted, into: &buf)
        FfiConverterBool.write(value.isConnected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeerDetails_lift(_ buf: RustBuffer) throws -> PeerDetails {
    return try FfiConverterTypePeerDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePeerDetails_lower(_ value: PeerDetails) -> RustBuffer {
    return FfiConverterTypePeerDetails.lower(value)
}


public struct PendingBalanceDetails {
    public var channelId: String
    public var nodeId: String
    public var amountMsats: Int64
    public var fundingTxId: String
    public var fundingTxVout: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelId: String, nodeId: String, amountMsats: Int64, fundingTxId: String, fundingTxVout: Int64) {
        self.channelId = channelId
        self.nodeId = nodeId
        self.amountMsats = amountMsats
        self.fundingTxId = fundingTxId
        self.fundingTxVout = fundingTxVout
    }
}

#if compiler(>=6)
extension PendingBalanceDetails: Sendable {}
#endif


extension PendingBalanceDetails: Equatable, Hashable {
    public static func ==(lhs: PendingBalanceDetails, rhs: PendingBalanceDetails) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        if lhs.fundingTxId != rhs.fundingTxId {
            return false
        }
        if lhs.fundingTxVout != rhs.fundingTxVout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(nodeId)
        hasher.combine(amountMsats)
        hasher.combine(fundingTxId)
        hasher.combine(fundingTxVout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePendingBalanceDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PendingBalanceDetails {
        return
            try PendingBalanceDetails(
                channelId: FfiConverterString.read(from: &buf), 
                nodeId: FfiConverterString.read(from: &buf), 
                amountMsats: FfiConverterInt64.read(from: &buf), 
                fundingTxId: FfiConverterString.read(from: &buf), 
                fundingTxVout: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PendingBalanceDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.channelId, into: &buf)
        FfiConverterString.write(value.nodeId, into: &buf)
        FfiConverterInt64.write(value.amountMsats, into: &buf)
        FfiConverterString.write(value.fundingTxId, into: &buf)
        FfiConverterInt64.write(value.fundingTxVout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingBalanceDetails_lift(_ buf: RustBuffer) throws -> PendingBalanceDetails {
    return try FfiConverterTypePendingBalanceDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePendingBalanceDetails_lower(_ value: PendingBalanceDetails) -> RustBuffer {
    return FfiConverterTypePendingBalanceDetails.lower(value)
}


public struct PhoenixdConfig {
    public var url: String
    public var password: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, password: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.url = url
        self.password = password
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension PhoenixdConfig: Sendable {}
#endif


extension PhoenixdConfig: Equatable, Hashable {
    public static func ==(lhs: PhoenixdConfig, rhs: PhoenixdConfig) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(password)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePhoenixdConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PhoenixdConfig {
        return
            try PhoenixdConfig(
                url: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PhoenixdConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoenixdConfig_lift(_ buf: RustBuffer) throws -> PhoenixdConfig {
    return try FfiConverterTypePhoenixdConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePhoenixdConfig_lower(_ value: PhoenixdConfig) -> RustBuffer {
    return FfiConverterTypePhoenixdConfig.lower(value)
}


public struct SpeedConfig {
    public var baseUrl: String?
    public var apiKey: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseUrl: String? = "https://api.tryspeed.com", apiKey: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.baseUrl = baseUrl
        self.apiKey = apiKey
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension SpeedConfig: Sendable {}
#endif


extension SpeedConfig: Equatable, Hashable {
    public static func ==(lhs: SpeedConfig, rhs: SpeedConfig) -> Bool {
        if lhs.baseUrl != rhs.baseUrl {
            return false
        }
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseUrl)
        hasher.combine(apiKey)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpeedConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpeedConfig {
        return
            try SpeedConfig(
                baseUrl: FfiConverterOptionString.read(from: &buf), 
                apiKey: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SpeedConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.baseUrl, into: &buf)
        FfiConverterString.write(value.apiKey, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpeedConfig_lift(_ buf: RustBuffer) throws -> SpeedConfig {
    return try FfiConverterTypeSpeedConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpeedConfig_lower(_ value: SpeedConfig) -> RustBuffer {
    return FfiConverterTypeSpeedConfig.lower(value)
}


public struct StrikeConfig {
    public var baseUrl: String?
    public var apiKey: String
    public var socks5Proxy: String?
    public var acceptInvalidCerts: Bool?
    public var httpTimeout: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(baseUrl: String? = "https://api.strike.me/v1", apiKey: String, socks5Proxy: String? = "", acceptInvalidCerts: Bool? = true, httpTimeout: Int64? = Int64(120)) {
        self.baseUrl = baseUrl
        self.apiKey = apiKey
        self.socks5Proxy = socks5Proxy
        self.acceptInvalidCerts = acceptInvalidCerts
        self.httpTimeout = httpTimeout
    }
}

#if compiler(>=6)
extension StrikeConfig: Sendable {}
#endif


extension StrikeConfig: Equatable, Hashable {
    public static func ==(lhs: StrikeConfig, rhs: StrikeConfig) -> Bool {
        if lhs.baseUrl != rhs.baseUrl {
            return false
        }
        if lhs.apiKey != rhs.apiKey {
            return false
        }
        if lhs.socks5Proxy != rhs.socks5Proxy {
            return false
        }
        if lhs.acceptInvalidCerts != rhs.acceptInvalidCerts {
            return false
        }
        if lhs.httpTimeout != rhs.httpTimeout {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(baseUrl)
        hasher.combine(apiKey)
        hasher.combine(socks5Proxy)
        hasher.combine(acceptInvalidCerts)
        hasher.combine(httpTimeout)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStrikeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StrikeConfig {
        return
            try StrikeConfig(
                baseUrl: FfiConverterOptionString.read(from: &buf), 
                apiKey: FfiConverterString.read(from: &buf), 
                socks5Proxy: FfiConverterOptionString.read(from: &buf), 
                acceptInvalidCerts: FfiConverterOptionBool.read(from: &buf), 
                httpTimeout: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: StrikeConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.baseUrl, into: &buf)
        FfiConverterString.write(value.apiKey, into: &buf)
        FfiConverterOptionString.write(value.socks5Proxy, into: &buf)
        FfiConverterOptionBool.write(value.acceptInvalidCerts, into: &buf)
        FfiConverterOptionInt64.write(value.httpTimeout, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStrikeConfig_lift(_ buf: RustBuffer) throws -> StrikeConfig {
    return try FfiConverterTypeStrikeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStrikeConfig_lower(_ value: StrikeConfig) -> RustBuffer {
    return FfiConverterTypeStrikeConfig.lower(value)
}


public struct TlvRecord {
    public var type: Int64
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: Int64, value: String) {
        self.type = type
        self.value = value
    }
}

#if compiler(>=6)
extension TlvRecord: Sendable {}
#endif


extension TlvRecord: Equatable, Hashable {
    public static func ==(lhs: TlvRecord, rhs: TlvRecord) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTLVRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TlvRecord {
        return
            try TlvRecord(
                type: FfiConverterInt64.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TlvRecord, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.type, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTLVRecord_lift(_ buf: RustBuffer) throws -> TlvRecord {
    return try FfiConverterTypeTLVRecord.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTLVRecord_lower(_ value: TlvRecord) -> RustBuffer {
    return FfiConverterTypeTLVRecord.lower(value)
}


public struct Transaction {
    public var type: String
    public var invoice: String
    public var description: String
    public var descriptionHash: String
    public var preimage: String
    public var paymentHash: String
    public var amountMsats: Int64
    public var feesPaid: Int64
    public var createdAt: Int64
    public var expiresAt: Int64
    public var settledAt: Int64
    public var payerNote: String?
    public var externalId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, invoice: String, description: String, descriptionHash: String, preimage: String, paymentHash: String, amountMsats: Int64, feesPaid: Int64, createdAt: Int64, expiresAt: Int64, settledAt: Int64, payerNote: String?, externalId: String?) {
        self.type = type
        self.invoice = invoice
        self.description = description
        self.descriptionHash = descriptionHash
        self.preimage = preimage
        self.paymentHash = paymentHash
        self.amountMsats = amountMsats
        self.feesPaid = feesPaid
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.settledAt = settledAt
        self.payerNote = payerNote
        self.externalId = externalId
    }
}

#if compiler(>=6)
extension Transaction: Sendable {}
#endif


extension Transaction: Equatable, Hashable {
    public static func ==(lhs: Transaction, rhs: Transaction) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.amountMsats != rhs.amountMsats {
            return false
        }
        if lhs.feesPaid != rhs.feesPaid {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.expiresAt != rhs.expiresAt {
            return false
        }
        if lhs.settledAt != rhs.settledAt {
            return false
        }
        if lhs.payerNote != rhs.payerNote {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(invoice)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(preimage)
        hasher.combine(paymentHash)
        hasher.combine(amountMsats)
        hasher.combine(feesPaid)
        hasher.combine(createdAt)
        hasher.combine(expiresAt)
        hasher.combine(settledAt)
        hasher.combine(payerNote)
        hasher.combine(externalId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        return
            try Transaction(
                type: FfiConverterString.read(from: &buf), 
                invoice: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                descriptionHash: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf), 
                amountMsats: FfiConverterInt64.read(from: &buf), 
                feesPaid: FfiConverterInt64.read(from: &buf), 
                createdAt: FfiConverterInt64.read(from: &buf), 
                expiresAt: FfiConverterInt64.read(from: &buf), 
                settledAt: FfiConverterInt64.read(from: &buf), 
                payerNote: FfiConverterOptionString.read(from: &buf), 
                externalId: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.descriptionHash, into: &buf)
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
        FfiConverterInt64.write(value.amountMsats, into: &buf)
        FfiConverterInt64.write(value.feesPaid, into: &buf)
        FfiConverterInt64.write(value.createdAt, into: &buf)
        FfiConverterInt64.write(value.expiresAt, into: &buf)
        FfiConverterInt64.write(value.settledAt, into: &buf)
        FfiConverterOptionString.write(value.payerNote, into: &buf)
        FfiConverterOptionString.write(value.externalId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}


public struct UpdateChannelRequest {
    public var channelId: String
    public var nodeId: String
    public var forwardingFeeBaseMsat: Int64
    public var maxDustHtlcExposureFromFeeRateMultiplier: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(channelId: String, nodeId: String, forwardingFeeBaseMsat: Int64, maxDustHtlcExposureFromFeeRateMultiplier: Int64) {
        self.channelId = channelId
        self.nodeId = nodeId
        self.forwardingFeeBaseMsat = forwardingFeeBaseMsat
        self.maxDustHtlcExposureFromFeeRateMultiplier = maxDustHtlcExposureFromFeeRateMultiplier
    }
}

#if compiler(>=6)
extension UpdateChannelRequest: Sendable {}
#endif


extension UpdateChannelRequest: Equatable, Hashable {
    public static func ==(lhs: UpdateChannelRequest, rhs: UpdateChannelRequest) -> Bool {
        if lhs.channelId != rhs.channelId {
            return false
        }
        if lhs.nodeId != rhs.nodeId {
            return false
        }
        if lhs.forwardingFeeBaseMsat != rhs.forwardingFeeBaseMsat {
            return false
        }
        if lhs.maxDustHtlcExposureFromFeeRateMultiplier != rhs.maxDustHtlcExposureFromFeeRateMultiplier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(channelId)
        hasher.combine(nodeId)
        hasher.combine(forwardingFeeBaseMsat)
        hasher.combine(maxDustHtlcExposureFromFeeRateMultiplier)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateChannelRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateChannelRequest {
        return
            try UpdateChannelRequest(
                channelId: FfiConverterString.read(from: &buf), 
                nodeId: FfiConverterString.read(from: &buf), 
                forwardingFeeBaseMsat: FfiConverterInt64.read(from: &buf), 
                maxDustHtlcExposureFromFeeRateMultiplier: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateChannelRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.channelId, into: &buf)
        FfiConverterString.write(value.nodeId, into: &buf)
        FfiConverterInt64.write(value.forwardingFeeBaseMsat, into: &buf)
        FfiConverterInt64.write(value.maxDustHtlcExposureFromFeeRateMultiplier, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateChannelRequest_lift(_ buf: RustBuffer) throws -> UpdateChannelRequest {
    return try FfiConverterTypeUpdateChannelRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateChannelRequest_lower(_ value: UpdateChannelRequest) -> RustBuffer {
    return FfiConverterTypeUpdateChannelRequest.lower(value)
}


public enum ApiError: Swift.Error {

    
    
    case Http(reason: String
    )
    case Api(reason: String
    )
    case Json(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApiError: FfiConverterRustBuffer {
    typealias SwiftType = ApiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Http(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Api(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Json(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ApiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Http(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Api(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .Json(reason):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiError_lift(_ buf: RustBuffer) throws -> ApiError {
    return try FfiConverterTypeApiError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApiError_lower(_ value: ApiError) -> RustBuffer {
    return FfiConverterTypeApiError.lower(value)
}


extension ApiError: Equatable, Hashable {}




extension ApiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InvoiceType {
    
    case bolt11
    case bolt12
}


#if compiler(>=6)
extension InvoiceType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvoiceType: FfiConverterRustBuffer {
    typealias SwiftType = InvoiceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bolt11
        
        case 2: return .bolt12
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InvoiceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .bolt11:
            writeInt(&buf, Int32(1))
        
        
        case .bolt12:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceType_lift(_ buf: RustBuffer) throws -> InvoiceType {
    return try FfiConverterTypeInvoiceType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvoiceType_lower(_ value: InvoiceType) -> RustBuffer {
    return FfiConverterTypeInvoiceType.lower(value)
}


extension InvoiceType: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = Transaction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransaction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransaction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeInvoiceType: FfiConverterRustBuffer {
    typealias SwiftType = InvoiceType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInvoiceType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInvoiceType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOffer: FfiConverterRustBuffer {
    typealias SwiftType = [Offer]

    public static func write(_ value: [Offer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOffer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Offer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Offer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOffer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePendingBalanceDetails: FfiConverterRustBuffer {
    typealias SwiftType = [PendingBalanceDetails]

    public static func write(_ value: [PendingBalanceDetails], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePendingBalanceDetails.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PendingBalanceDetails] {
        let len: Int32 = try readInt(&buf)
        var seq = [PendingBalanceDetails]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePendingBalanceDetails.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureLniInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        // Note: it's important we call either `handleSuccess` or `handleError` exactly once.  Each
        // call consumes an Arc reference, which means there should be no possibility of a double
        // call.  The following code is structured so that will will never call both `handleSuccess`
        // and `handleError`, even in the face of weird errors.
        //
        // On platforms that need extra machinery to make C-ABI calls, like JNA or ctypes, it's
        // possible that we fail to make either call.  However, it doesn't seem like this is
        // possible on Swift since swift can just make the C call directly.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        // See the note in uniffiTraitInterfaceCallAsync for details on `handleSuccess` and
        // `handleError`.
        var callResult: T
        do {
            callResult = try await makeCall()
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
            return
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
            return
        }
        handleSuccess(callResult)
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountLni() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Create a Blink node as a polymorphic LightningNode
 */
public func createBlinkNode(config: BlinkConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_blink_node(
        FfiConverterTypeBlinkConfig_lower(config),$0
    )
})
}
/**
 * Create a CLN node as a polymorphic LightningNode
 */
public func createClnNode(config: ClnConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_cln_node(
        FfiConverterTypeClnConfig_lower(config),$0
    )
})
}
public func createInvoice(config: LndConfig, params: CreateInvoiceParams)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_create_invoice(FfiConverterTypeLndConfig_lower(config),FfiConverterTypeCreateInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
/**
 * Create an LND node as a polymorphic LightningNode
 */
public func createLndNode(config: LndConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_lnd_node(
        FfiConverterTypeLndConfig_lower(config),$0
    )
})
}
/**
 * Create an NWC node as a polymorphic LightningNode
 */
public func createNwcNode(config: NwcConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_nwc_node(
        FfiConverterTypeNwcConfig_lower(config),$0
    )
})
}
/**
 * Create a Phoenixd node as a polymorphic LightningNode
 */
public func createPhoenixdNode(config: PhoenixdConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_phoenixd_node(
        FfiConverterTypePhoenixdConfig_lower(config),$0
    )
})
}
/**
 * Create a Speed node as a polymorphic LightningNode
 */
public func createSpeedNode(config: SpeedConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_speed_node(
        FfiConverterTypeSpeedConfig_lower(config),$0
    )
})
}
/**
 * Create a Strike node as a polymorphic LightningNode
 */
public func createStrikeNode(config: StrikeConfig) -> LightningNode  {
    return try!  FfiConverterTypeLightningNode_lift(try! rustCall() {
    uniffi_lni_fn_func_create_strike_node(
        FfiConverterTypeStrikeConfig_lower(config),$0
    )
})
}
public func decode(config: LndConfig, invoiceStr: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_decode(FfiConverterTypeLndConfig_lower(config),FfiConverterString.lower(invoiceStr)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
public func getInfo(config: LndConfig)async throws  -> NodeInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_get_info(FfiConverterTypeLndConfig_lower(config)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNodeInfo_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
public func listTransactions(config: LndConfig, from: Int64?, limit: Int64?, search: String?)async throws  -> [Transaction]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_list_transactions(FfiConverterTypeLndConfig_lower(config),FfiConverterOptionInt64.lower(from),FfiConverterOptionInt64.lower(limit),FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeTransaction.lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
public func lookupInvoice(config: LndConfig, paymentHash: String?, from: Int64?, limit: Int64?, search: String?)async throws  -> Transaction  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_lookup_invoice(FfiConverterTypeLndConfig_lower(config),FfiConverterOptionString.lower(paymentHash),FfiConverterOptionInt64.lower(from),FfiConverterOptionInt64.lower(limit),FfiConverterOptionString.lower(search)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransaction_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
public func onInvoiceEvents(config: LndConfig, params: OnInvoiceEventParams, callback: OnInvoiceEventCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_on_invoice_events(FfiConverterTypeLndConfig_lower(config),FfiConverterTypeOnInvoiceEventParams_lower(params),FfiConverterTypeOnInvoiceEventCallback_lower(callback)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_void,
            completeFunc: ffi_lni_rust_future_complete_void,
            freeFunc: ffi_lni_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
public func payInvoice(config: LndConfig, params: PayInvoiceParams)async throws  -> PayInvoiceResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_pay_invoice(FfiConverterTypeLndConfig_lower(config),FfiConverterTypePayInvoiceParams_lower(params)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePayInvoiceResponse_lift,
            errorHandler: FfiConverterTypeApiError_lift
        )
}
public func sayAfterWithTokio(ms: UInt16, who: String, url: String, socks5Proxy: String?, headerKey: String?, headerValue: String?)async  -> String  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_lni_fn_func_say_after_with_tokio(FfiConverterUInt16.lower(ms),FfiConverterString.lower(who),FfiConverterString.lower(url),FfiConverterOptionString.lower(socks5Proxy),FfiConverterOptionString.lower(headerKey),FfiConverterOptionString.lower(headerValue)
                )
            },
            pollFunc: ffi_lni_rust_future_poll_rust_buffer,
            completeFunc: ffi_lni_rust_future_complete_rust_buffer,
            freeFunc: ffi_lni_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_lni_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_lni_checksum_func_create_blink_node() != 17663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_cln_node() != 2566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_invoice() != 17504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_lnd_node() != 38322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_nwc_node() != 906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_phoenixd_node() != 55373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_speed_node() != 45583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_create_strike_node() != 64378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_decode() != 11646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_get_info() != 59600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_list_transactions() != 33214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_lookup_invoice() != 23109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_on_invoice_events() != 37516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_pay_invoice() != 49062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_func_say_after_with_tokio() != 38516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_create_invoice() != 22694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_create_offer() != 55502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_decode() != 54938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_get_info() != 19853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_get_offer() != 40807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_list_offers() != 40534) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_list_transactions() != 14532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_lookup_invoice() != 56830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_on_invoice_events() != 56732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_pay_invoice() != 6408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_blinknode_pay_offer() != 62903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_create_invoice() != 60752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_create_offer() != 25049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_decode() != 51992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_get_info() != 36197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_get_offer() != 28823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_list_offers() != 62186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_list_transactions() != 13281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_lookup_invoice() != 54811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_on_invoice_events() != 2775) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_pay_invoice() != 54973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_clnnode_pay_offer() != 54278) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_get_info() != 63939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_create_invoice() != 58493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_pay_invoice() != 48894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_create_offer() != 56287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_get_offer() != 42130) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_list_offers() != 42685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_pay_offer() != 26809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_lookup_invoice() != 31149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_list_transactions() != 42286) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_decode() != 11638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lightningnode_on_invoice_events() != 18613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_create_invoice() != 5254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_create_offer() != 10647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_decode() != 7091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_get_info() != 61919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_get_offer() != 60794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_list_offers() != 33463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_list_transactions() != 55421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_lookup_invoice() != 28229) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_on_invoice_events() != 32797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_pay_invoice() != 32198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_lndnode_pay_offer() != 19259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_create_invoice() != 51322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_create_offer() != 538) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_decode() != 7231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_get_info() != 65370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_get_offer() != 14257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_list_offers() != 27006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_list_transactions() != 54832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_lookup_invoice() != 35070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_on_invoice_events() != 14842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_pay_invoice() != 58905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_nwcnode_pay_offer() != 3796) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_oninvoiceeventcallback_success() != 903) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_oninvoiceeventcallback_pending() != 1693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_oninvoiceeventcallback_failure() != 16695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_create_invoice() != 20327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_create_offer() != 39667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_decode() != 20826) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_get_info() != 1217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_get_offer() != 28141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_list_offers() != 50531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_list_transactions() != 13794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_lookup_invoice() != 10729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_on_invoice_events() != 56570) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_pay_invoice() != 33526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_phoenixdnode_pay_offer() != 58136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_create_invoice() != 60705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_create_offer() != 56380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_decode() != 5102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_get_info() != 30713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_get_offer() != 32733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_list_offers() != 1177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_list_transactions() != 55207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_lookup_invoice() != 48093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_on_invoice_events() != 24545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_pay_invoice() != 14288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_speednode_pay_offer() != 33016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_create_invoice() != 3038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_create_offer() != 33487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_decode() != 50868) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_get_info() != 10078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_get_offer() != 7451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_list_offers() != 48221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_list_transactions() != 57423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_lookup_invoice() != 33761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_on_invoice_events() != 49487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_pay_invoice() != 26323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_method_strikenode_pay_offer() != 30630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_blinknode_new() != 49992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_clnnode_new() != 59940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_lndnode_new() != 57532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_nwcnode_new() != 52395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_phoenixdnode_new() != 22874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_speednode_new() != 58509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_lni_checksum_constructor_strikenode_new() != 54374) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLightningNode()
    uniffiCallbackInitOnInvoiceEventCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureLniInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all